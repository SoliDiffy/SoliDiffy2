diff --git a/contracts/UniswapV3Pair.sol b/contracts/UniswapV3Pair.sol
index dd390b11..1adb678b 100644
--- a/contracts/UniswapV3Pair.sol
+++ b/contracts/UniswapV3Pair.sol
@@ -528,7 +528,7 @@ contract UniswapV3Pair is IUniswapV3Pair {
     }
 
     struct StepComputations {
-        // price for the tick (1/0)
+        // price for the tick
         FixedPoint.uq112x112 nextPrice;
         // how much is being swapped in in this step
         uint112 amountIn;
@@ -551,8 +551,8 @@ contract UniswapV3Pair is IUniswapV3Pair {
             assert(tick < TickMath.MAX_TICK);
             assert(reserve0Virtual >= TOKEN_MIN && reserve1Virtual >= TOKEN_MIN);
 
+            // get the inclusive price for the next tick we're moving toward
             StepComputations memory step;
-            // get the price for the next tick we're moving toward
             step.nextPrice = params.zeroForOne ? TickMath.getRatioAtTick(tick) : TickMath.getRatioAtTick(tick + 1);
 
             // protect liquidity providers by adjusting the fee only if the current fee is greater than the stored fee
@@ -563,15 +563,14 @@ contract UniswapV3Pair is IUniswapV3Pair {
                 ? (reserve0Virtual, reserve1Virtual)
                 : (reserve1Virtual, reserve0Virtual);
 
-            // compute the ~minimum amount of input token required s.t. the price equals or exceeds the target price
-            // _after_ computing the corresponding output amount according to x * y = k given the current fee
+            // TODO are there issues with using reciprocal here?
+            // compute the ~minimum amount of input token required s.t. the price _equals or exceeds_ the target price
+            // after computing the corresponding output amount according to x * y = k, given the current fee
             uint112 amountInRequiredForShift = PriceMath.getInputToRatio(
                 reserveInVirtual,
                 reserveOutVirtual,
                 fee,
-                step.nextPrice,
-                params.zeroForOne ? TickMath.getRatioAtTick(-tick) : TickMath.getRatioAtTick(-(tick + 1)),
-                params.zeroForOne
+                params.zeroForOne ? step.nextPrice.reciprocal() : step.nextPrice
             );
 
             // TODO ensure that there's no off-by-one error here while transitioning ticks
@@ -582,16 +581,18 @@ contract UniswapV3Pair is IUniswapV3Pair {
                 // calculate the owed output amount, given the current fee
                 step.amountOut = PriceMath.getAmountOut(reserveInVirtual, reserveOutVirtual, fee, step.amountIn);
 
+                // TODO we should ensure that step.amountOut + 1 always results in a price exceeding the target
+
                 // calculate the maximum output amount s.t. the reserves price is guaranteed to be as close as possible
                 // to the target price _without_ exceeding it
                 uint112 reserveInVirtualNext = (uint256(reserveInVirtual) + step.amountIn).toUint112();
-                uint256 reserveOutVirtualThreshold = params.zeroForOne
-                    ? PriceMath.getQuoteFromDenominator(reserveInVirtualNext, step.nextPrice)
-                    : PriceMath.getQuoteFromNumerator(reserveInVirtualNext, step.nextPrice);
-                step.amountOut = Math.min(
-                    step.amountOut,
-                    reserveOutVirtual.sub(reserveOutVirtualThreshold)
-                ).toUint112();
+                uint256 reserveOutVirtualThreshold = PriceMath.getReserveOutThreshold(
+                    params.zeroForOne,
+                    reserveInVirtualNext,
+                    step.nextPrice
+                );
+                uint112 amountOutMaximum = reserveOutVirtual.sub(reserveOutVirtualThreshold).toUint112();
+                step.amountOut = Math.min(step.amountOut, amountOutMaximum).toUint112();
 
                 if (params.zeroForOne) {
                     reserve0Virtual = (uint256(reserve0Virtual) + step.amountIn).toUint112();
@@ -601,30 +602,29 @@ contract UniswapV3Pair is IUniswapV3Pair {
                     reserve1Virtual = (uint256(reserve1Virtual) + step.amountIn).toUint112();
                 }
 
+                // TODO add this back when we know its working
                 // TODO remove this eventually, it's meant to ensure our overshoot compensation logic is correct
-                {
-                    FixedPoint.uq112x112 memory priceNext = FixedPoint.fraction(reserve1Virtual, reserve0Virtual);
-                    if (params.zeroForOne) {
-                        assert(priceNext._x >= step.nextPrice._x);
-                    } else {
-                        assert(priceNext._x <= step.nextPrice._x);
-                    }
-                }
+                // {
+                //     FixedPoint.uq112x112 memory priceNext = FixedPoint.fraction(reserve1Virtual, reserve0Virtual);
+                //     if (params.zeroForOne) {
+                //         assert(priceNext._x >= step.nextPrice._x);
+                //     } else {
+                //         assert(priceNext._x <= step.nextPrice._x);
+                //     }
+                // }
 
                 amountInRemaining = amountInRemaining.sub(step.amountIn).toUint112();
                 amountOut = (uint256(amountOut) + step.amountOut).toUint112();
             }
 
             // if a positive input amount still remains, we have to shift to the next tick
-            // TODO we also have to run this if we're moving right and the price is exactly on the target tick
             if (amountInRemaining > 0) {
                 TickInfo storage tickInfo = tickInfos[tick];
 
                 // if the tick is initialized, we must update it
                 if (tickInfo.growthOutside._x != 0) {
                     // calculate the amount of reserves to kick in/out
-                    // TODO gas-golf this to an int256
-                    int120 token1VirtualDelta;
+                    int256 token1VirtualDelta;
                     for (uint8 i = 0; i < NUM_FEE_OPTIONS; i++) {
                         token1VirtualDelta += tickInfo.token1VirtualDeltas[i];
                     }
@@ -634,7 +634,6 @@ contract UniswapV3Pair is IUniswapV3Pair {
                     // the price toward the direction we're moving (past the tick), if it has to move at all?
                     int256 token0VirtualDelta;
                     {
-                        // this is essentially getQuoteFromNumerator, but we probably don't want to round up...
                         uint256 token0VirtualDeltaUnsigned = (uint256(
                             token1VirtualDelta < 0 ? -token1VirtualDelta : token1VirtualDelta
                         ) << 112) / step.nextPrice._x;
