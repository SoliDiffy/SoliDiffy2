diff --git a/contracts/UniswapV3Pair.sol b/contracts/UniswapV3Pair.sol
index 34028f02..b786b34a 100644
--- a/contracts/UniswapV3Pair.sol
+++ b/contracts/UniswapV3Pair.sol
@@ -67,9 +67,7 @@ contract UniswapV3Pair is IUniswapV3Pair {
         // the tick accumulator, i.e. tick * time elapsed since the pair was first initialized
         int56 tickCumulativeLast;
         // whether the pair is locked for swapping
-        // packed with a boolean representing whether the price is at the lower bounds of the
-        // tick boundary but the tick transition has already happened
-        uint8 unlockedAndPriceBit;
+        bool unlocked;
     }
 
     Slot0 public override slot0;
@@ -107,13 +105,11 @@ contract UniswapV3Pair is IUniswapV3Pair {
     }
     mapping(bytes32 => Position) public positions;
 
-    // lock the pair for operations that do not modify the price, i.e. everything but swap
-    modifier lockNoPriceMovement() {
-        uint8 uapb = slot0.unlockedAndPriceBit;
-        require(uapb & 1 == 1, 'UniswapV3Pair::lock: reentrancy prohibited');
-        slot0.unlockedAndPriceBit = uapb ^ 1;
+    modifier lock() {
+        require(slot0.unlocked, 'UniswapV3Pair::lock: reentrancy prohibited');
+        slot0.unlocked = false;
         _;
-        slot0.unlockedAndPriceBit = uapb;
+        slot0.unlocked = true;
     }
 
     function _getPosition(
@@ -130,13 +126,7 @@ contract UniswapV3Pair is IUniswapV3Pair {
     }
 
     function tickCurrent() public view override returns (int24) {
-        return _tickCurrent(slot0);
-    }
-
-    function _tickCurrent(Slot0 memory _slot0) internal pure returns (int24) {
-        int24 tick = SqrtTickMath.getTickAtSqrtRatio(_slot0.sqrtPriceCurrent);
-        if (_slot0.unlockedAndPriceBit & 2 == 2) return tick - 1;
-        return tick;
+        return SqrtTickMath.getTickAtSqrtRatio(slot0.sqrtPriceCurrent);
     }
 
     constructor() {
@@ -200,7 +190,7 @@ contract UniswapV3Pair is IUniswapV3Pair {
             blockTimestampLast: _blockTimestamp(),
             tickCumulativeLast: 0,
             sqrtPriceCurrent: FixedPoint96.uq64x96(sqrtPrice),
-            unlockedAndPriceBit: 1
+            unlocked: true
         });
 
         emit Initialized(sqrtPrice);
@@ -311,7 +301,7 @@ contract UniswapV3Pair is IUniswapV3Pair {
         address recipient,
         uint256 amount0Requested,
         uint256 amount1Requested
-    ) external override lockNoPriceMovement returns (uint256 amount0, uint256 amount1) {
+    ) external override lock returns (uint256 amount0, uint256 amount1) {
         Position storage position = _updatePosition(msg.sender, tickLower, tickUpper, 0, tickCurrent());
 
         if (amount0Requested == uint256(-1)) {
@@ -339,7 +329,7 @@ contract UniswapV3Pair is IUniswapV3Pair {
         int24 tickUpper,
         uint128 amount,
         bytes calldata data
-    ) public override lockNoPriceMovement returns (uint256 amount0, uint256 amount1) {
+    ) public override lock returns (uint256 amount0, uint256 amount1) {
         require(isInitialized(), 'UniswapV3Pair::mint: pair not initialized');
         require(amount > 0, 'UniswapV3Pair::mint: amount must be greater than 0');
 
@@ -380,7 +370,7 @@ contract UniswapV3Pair is IUniswapV3Pair {
         int24 tickLower,
         int24 tickUpper,
         uint128 amount
-    ) external override lockNoPriceMovement returns (uint256 amount0, uint256 amount1) {
+    ) external override lock returns (uint256 amount0, uint256 amount1) {
         require(isInitialized(), 'UniswapV3Pair::burn: pair not initialized');
         require(amount > 0, 'UniswapV3Pair::burn: amount must be greater than 0');
 
@@ -454,8 +444,6 @@ contract UniswapV3Pair is IUniswapV3Pair {
     }
 
     struct SwapParams {
-        // the value of slot0 at the beginning of the swap
-        Slot0 slot0Start;
         // the liquidity at the beginning of the swap
         uint128 liquidityStart;
         // the tick at the beginning of the swap
@@ -484,17 +472,13 @@ contract UniswapV3Pair is IUniswapV3Pair {
         FixedPoint128.uq128x128 feeGrowthGlobal;
         // the liquidity in range
         uint128 liquidityCurrent;
-        // whether the price is at the lower tickCurrent boundary and a tick transition has already occurred
-        bool priceBit;
     }
 
     struct StepComputations {
         // the next initialized tick from the current tick in the swap direction
         int24 tickNext;
-        // the price at the beginning of the step
-        FixedPoint96.uq64x96 sqrtPriceStart;
         // sqrt(price) for the target tick (1/0)
-        FixedPoint96.uq64x96 sqrtPriceTarget;
+        FixedPoint96.uq64x96 sqrtPriceNext;
         // how much is being swapped in in this step
         uint256 amountIn;
         // how much is being swapped out in the current step
@@ -513,23 +497,18 @@ contract UniswapV3Pair is IUniswapV3Pair {
     }
 
     function _swap(SwapParams memory params) private returns (uint256 amountCalculated) {
-        slot0.unlockedAndPriceBit = params.slot0Start.unlockedAndPriceBit ^ 1;
-
         SwapState memory state =
             SwapState({
                 amountSpecifiedRemaining: params.amountSpecified,
                 tick: params.tickStart,
-                sqrtPrice: params.slot0Start.sqrtPriceCurrent,
+                sqrtPrice: slot0.sqrtPriceCurrent,
                 feeGrowthGlobal: params.zeroForOne ? feeGrowthGlobal0 : feeGrowthGlobal1,
-                liquidityCurrent: params.liquidityStart,
-                priceBit: params.slot0Start.unlockedAndPriceBit & 2 == 2
+                liquidityCurrent: params.liquidityStart
             });
 
         while (state.amountSpecifiedRemaining != 0) {
             StepComputations memory step;
 
-            step.sqrtPriceStart = state.sqrtPrice;
-
             (step.tickNext, ) = tickBitmap.nextInitializedTickWithinOneWord(
                 closestTick(state.tick),
                 params.zeroForOne,
@@ -540,12 +519,13 @@ contract UniswapV3Pair is IUniswapV3Pair {
             else require(step.tickNext <= MAX_TICK, 'UniswapV3Pair::_swap: crossed max tick');
 
             // get the price for the next tick we're moving toward
-            step.sqrtPriceTarget = SqrtTickMath.getSqrtRatioAtTick(step.tickNext);
+            step.sqrtPriceNext = SqrtTickMath.getSqrtRatioAtTick(step.tickNext);
 
-            if (state.sqrtPrice._x != step.sqrtPriceTarget._x) {
+            // if there might be room to move in the current tick, continue calculations
+            if (params.zeroForOne == false || (state.sqrtPrice._x > step.sqrtPriceNext._x)) {
                 (state.sqrtPrice, step.amountIn, step.amountOut, step.feeAmount) = SwapMath.computeSwapStep(
                     state.sqrtPrice,
-                    step.sqrtPriceTarget,
+                    step.sqrtPriceNext,
                     state.liquidityCurrent,
                     state.amountSpecifiedRemaining,
                     fee
@@ -565,11 +545,17 @@ contract UniswapV3Pair is IUniswapV3Pair {
                 state.feeGrowthGlobal._x += FixedPoint128.fraction(step.feeAmount, state.liquidityCurrent)._x;
             }
 
-            // shift tick if we reached the next price target
-            if (state.sqrtPrice._x == step.sqrtPriceTarget._x) {
+            // we have to shift to the next tick if either of two conditions are true:
+            // 1) a positive input amount remains
+            // 2) if we're moving right and the price is exactly on the target tick
+            // TODO ensure that there's no off-by-one error here while transitioning ticks in either direction
+            if (
+                state.amountSpecifiedRemaining != 0 ||
+                (params.zeroForOne == false && state.sqrtPrice._x == step.sqrtPriceNext._x)
+            ) {
                 Tick.Info storage tickInfo = tickInfos[step.tickNext];
 
-                // if the tick is initialized, run the tick transition
+                // if the tick is initialized, update it
                 if (tickInfo.liquidityGross > 0) {
                     // update tick info
                     tickInfo.feeGrowthOutside0 = FixedPoint128.uq128x128(
@@ -590,11 +576,12 @@ contract UniswapV3Pair is IUniswapV3Pair {
                     }
                 }
 
+                // todo: this might not be ok. the price may not move due to the remaining input amount!
+                // original rationale: this is ok because we still have amountInRemaining so price is guaranteed to be
+                // less than the tick after swapping the remaining amount in
                 state.tick = params.zeroForOne ? step.tickNext - 1 : step.tickNext;
-                state.priceBit = params.zeroForOne;
             } else {
-                state.priceBit = state.priceBit && params.zeroForOne && state.sqrtPrice._x == step.sqrtPriceStart._x;
-                state.tick = SqrtTickMath.getTickAtSqrtRatio(state.sqrtPrice) + (state.priceBit ? int24(-1) : int24(0));
+                state.tick = SqrtTickMath.getTickAtSqrtRatio(state.sqrtPrice);
             }
         }
 
@@ -605,20 +592,15 @@ contract UniswapV3Pair is IUniswapV3Pair {
 
         // the price moved at least one tick, update the accumulator
         if (state.tick != params.tickStart) {
-            uint32 _blockTimestampLast = params.slot0Start.blockTimestampLast;
+            uint32 _blockTimestampLast = slot0.blockTimestampLast;
             if (_blockTimestampLast != params.blockTimestamp) {
                 slot0.blockTimestampLast = params.blockTimestamp;
                 // overflow desired
-                slot0.tickCumulativeLast =
-                    params.slot0Start.tickCumulativeLast +
-                    int56(params.blockTimestamp - _blockTimestampLast) *
-                    params.tickStart;
+                slot0.tickCumulativeLast += int56(params.blockTimestamp - _blockTimestampLast) * params.tickStart;
             }
         }
 
         slot0.sqrtPriceCurrent = state.sqrtPrice;
-        // still locked until after the callback, but need to record the price bit
-        slot0.unlockedAndPriceBit = state.priceBit ? 2 : 0;
 
         if (params.zeroForOne) {
             feeGrowthGlobal0 = state.feeGrowthGlobal;
@@ -652,7 +634,6 @@ contract UniswapV3Pair is IUniswapV3Pair {
                 'UniswapV3Pair::_swap: insufficient input amount'
             );
         }
-        slot0.unlockedAndPriceBit = state.priceBit ? 3 : 1;
     }
 
     // positive (negative) numbers specify exact input (output) amounts, return values are output (input) amounts
@@ -661,19 +642,14 @@ contract UniswapV3Pair is IUniswapV3Pair {
         int256 amountSpecified,
         address recipient,
         bytes calldata data
-    ) external override returns (uint256 amountCalculated) {
+    ) external override lock returns (uint256 amountCalculated) {
         require(amountSpecified != 0, 'UniswapV3Pair::swap: amountSpecified must not be 0');
 
-        Slot0 memory _slot0 = slot0;
-
-        require(_slot0.unlockedAndPriceBit & 1 == 1, 'UniswapV3Pair::swap: reentrancy prohibited');
-
         return
             _swap(
                 SwapParams({
-                    slot0Start: _slot0,
-                    tickStart: _tickCurrent(_slot0),
                     liquidityStart: slot1.liquidityCurrent,
+                    tickStart: tickCurrent(),
                     zeroForOne: zeroForOne,
                     amountSpecified: amountSpecified,
                     recipient: recipient,
@@ -687,7 +663,7 @@ contract UniswapV3Pair is IUniswapV3Pair {
         address token,
         address recipient,
         uint256 amount
-    ) external override lockNoPriceMovement {
+    ) external override lock {
         require(msg.sender == IUniswapV3Factory(factory).owner(), 'UniswapV3Pair::recover: caller not owner');
 
         uint256 token0Balance = IERC20(token0).balanceOf(address(this));
@@ -706,7 +682,7 @@ contract UniswapV3Pair is IUniswapV3Pair {
     function collect(uint256 amount0Requested, uint256 amount1Requested)
         external
         override
-        lockNoPriceMovement
+        lock
         returns (uint256 amount0, uint256 amount1)
     {
         if (amount0Requested == uint256(-1)) {
