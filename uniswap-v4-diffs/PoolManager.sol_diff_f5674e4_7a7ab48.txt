diff --git a/src/PoolManager.sol b/src/PoolManager.sol
index 6366f87b..6fbe0b45 100644
--- a/src/PoolManager.sol
+++ b/src/PoolManager.sol
@@ -13,7 +13,7 @@ import {NoDelegateCall} from "./NoDelegateCall.sol";
 import {Owned} from "./Owned.sol";
 import {IHooks} from "./interfaces/IHooks.sol";
 import {IPoolManager} from "./interfaces/IPoolManager.sol";
-import {ILockCallback} from "./interfaces/callback/ILockCallback.sol";
+import {IUnlockCallback} from "./interfaces/callback/IUnlockCallback.sol";
 import {ProtocolFees} from "./ProtocolFees.sol";
 import {ERC6909Claims} from "./ERC6909Claims.sol";
 import {PoolId, PoolIdLibrary} from "./types/PoolId.sol";
@@ -40,7 +40,7 @@ contract PoolManager is IPoolManager, ProtocolFees, NoDelegateCall, ERC6909Claim
     int24 public constant MIN_TICK_SPACING = TickMath.MIN_TICK_SPACING;
 
     /// @dev Represents the currencies due/owed to each caller.
-    /// Must all net to zero when the lock is released.
+    /// Must all net to zero when manager gets locked again
     /// TODO this needs to be transient
     mapping(address caller => mapping(Currency currency => int256 currencyDelta)) public currencyDelta;
 
@@ -87,13 +87,13 @@ contract PoolManager is IPoolManager, ProtocolFees, NoDelegateCall, ERC6909Claim
         return pools[id].positions.get(_owner, tickLower, tickUpper);
     }
 
-    function isLockSet() external view returns (bool) {
-        return Lock.isLocked();
+    function isUnlocked() external view override returns (bool) {
+        return Lock.isUnlocked();
     }
 
-    /// @notice This will revert if the contract is not locked
-    modifier isLocked() {
-        if (!Lock.isLocked()) revert ManagerNotLocked();
+    /// @notice This will revert if the contract is locked
+    modifier onlyWhenUnlocked() {
+        if (!Lock.isUnlocked()) revert ManagerLocked();
         _;
     }
 
@@ -125,16 +125,16 @@ contract PoolManager is IPoolManager, ProtocolFees, NoDelegateCall, ERC6909Claim
     }
 
     /// @inheritdoc IPoolManager
-    function lock(bytes calldata data) external payable override returns (bytes memory result) {
-        if (Lock.isLocked()) revert AlreadyLocked();
+    function unlock(bytes calldata data) external payable override returns (bytes memory result) {
+        if (Lock.isUnlocked()) revert AlreadyUnlocked();
 
-        Lock.lock();
+        Lock.unlock();
 
         // the caller does everything in this callback, including paying what they owe via calls to settle
-        result = ILockCallback(msg.sender).lockAcquired(data);
+        result = IUnlockCallback(msg.sender).unlockCallback(data);
 
         if (NonZeroDeltaCount.read() != 0) revert CurrencyNotSettled();
-        Lock.unlock();
+        Lock.lock();
     }
 
     function _accountDelta(Currency currency, int128 delta) internal {
@@ -169,7 +169,7 @@ contract PoolManager is IPoolManager, ProtocolFees, NoDelegateCall, ERC6909Claim
         PoolKey memory key,
         IPoolManager.ModifyLiquidityParams memory params,
         bytes calldata hookData
-    ) external override noDelegateCall isLocked returns (BalanceDelta delta) {
+    ) external override noDelegateCall onlyWhenUnlocked returns (BalanceDelta delta) {
         PoolId id = key.toId();
         _checkPoolInitialized(id);
 
@@ -197,7 +197,7 @@ contract PoolManager is IPoolManager, ProtocolFees, NoDelegateCall, ERC6909Claim
         external
         override
         noDelegateCall
-        isLocked
+        onlyWhenUnlocked
         returns (BalanceDelta delta)
     {
         PoolId id = key.toId();
@@ -238,7 +238,7 @@ contract PoolManager is IPoolManager, ProtocolFees, NoDelegateCall, ERC6909Claim
         external
         override
         noDelegateCall
-        isLocked
+        onlyWhenUnlocked
         returns (BalanceDelta delta)
     {
         PoolId id = key.toId();
@@ -254,7 +254,7 @@ contract PoolManager is IPoolManager, ProtocolFees, NoDelegateCall, ERC6909Claim
     }
 
     /// @inheritdoc IPoolManager
-    function take(Currency currency, address to, uint256 amount) external override noDelegateCall isLocked {
+    function take(Currency currency, address to, uint256 amount) external override noDelegateCall onlyWhenUnlocked {
         // subtraction must be safe
         _accountDelta(currency, -(amount.toInt128()));
         reservesOf[currency] -= amount;
@@ -262,7 +262,14 @@ contract PoolManager is IPoolManager, ProtocolFees, NoDelegateCall, ERC6909Claim
     }
 
     /// @inheritdoc IPoolManager
-    function settle(Currency currency) external payable override noDelegateCall isLocked returns (uint256 paid) {
+    function settle(Currency currency)
+        external
+        payable
+        override
+        noDelegateCall
+        onlyWhenUnlocked
+        returns (uint256 paid)
+    {
         uint256 reservesBefore = reservesOf[currency];
         reservesOf[currency] = currency.balanceOfSelf();
         paid = reservesOf[currency] - reservesBefore;
@@ -270,14 +277,14 @@ contract PoolManager is IPoolManager, ProtocolFees, NoDelegateCall, ERC6909Claim
     }
 
     /// @inheritdoc IPoolManager
-    function mint(address to, uint256 id, uint256 amount) external override noDelegateCall isLocked {
+    function mint(address to, uint256 id, uint256 amount) external override noDelegateCall onlyWhenUnlocked {
         // subtraction must be safe
         _accountDelta(CurrencyLibrary.fromId(id), -(amount.toInt128()));
         _mint(to, id, amount);
     }
 
     /// @inheritdoc IPoolManager
-    function burn(address from, uint256 id, uint256 amount) external override noDelegateCall isLocked {
+    function burn(address from, uint256 id, uint256 amount) external override noDelegateCall onlyWhenUnlocked {
         _accountDelta(CurrencyLibrary.fromId(id), amount.toInt128());
         _burnFrom(from, id, amount);
     }
@@ -317,7 +324,7 @@ contract PoolManager is IPoolManager, ProtocolFees, NoDelegateCall, ERC6909Claim
         return value;
     }
 
-    function getLockNonzeroDeltaCount() external view returns (uint256 _nonzeroDeltaCount) {
+    function getNonzeroDeltaCount() external view returns (uint256 _nonzeroDeltaCount) {
         return NonZeroDeltaCount.read();
     }
 
