diff --git a/test/PoolManager.t.sol b/test/PoolManager.t.sol
index 93932f91..f1a50d91 100644
--- a/test/PoolManager.t.sol
+++ b/test/PoolManager.t.sol
@@ -973,6 +973,224 @@ contract PoolManagerTest is Test, Deployers, GasSnapshot {
         assertEq(manager.protocolFeesAccrued(currency0), 0);
     }
 
+    function test_noop_gas(uint160 sqrtPriceX96) public {
+        // Assumptions tested in Pool.t.sol
+        sqrtPriceX96 = uint160(bound(sqrtPriceX96, TickMath.MIN_SQRT_RATIO, TickMath.MAX_SQRT_RATIO - 1));
+
+        address payable hookAddr = payable(
+            address(
+                uint160(
+                    Hooks.BEFORE_ADD_LIQUIDITY_FLAG | Hooks.BEFORE_SWAP_FLAG | Hooks.BEFORE_DONATE_FLAG
+                        | Hooks.NO_OP_FLAG
+                )
+            )
+        );
+
+        vm.etch(hookAddr, vm.getDeployedCode("NoOpTestHooks.sol:NoOpTestHooks"));
+
+        (key,) = initPool(currency0, currency1, IHooks(hookAddr), 100, SQRT_RATIO_1_1, ZERO_BYTES);
+
+        // Test add liquidity
+        snapStart("modify position with noop");
+        BalanceDelta delta = modifyLiquidityRouter.modifyLiquidity(
+            key, IPoolManager.ModifyLiquidityParams(-120, 120, 10 ether), ZERO_BYTES
+        );
+        snapEnd();
+
+        // Swap
+        IPoolManager.SwapParams memory swapParams =
+            IPoolManager.SwapParams({zeroForOne: true, amountSpecified: 100, sqrtPriceLimitX96: SQRT_RATIO_1_2});
+
+        PoolSwapTest.TestSettings memory testSettings =
+            PoolSwapTest.TestSettings({withdrawTokens: true, settleUsingTransfer: true, currencyAlreadySent: false});
+
+        snapStart("swap with noop");
+        delta = swapRouter.swap(key, swapParams, testSettings, ZERO_BYTES);
+        snapEnd();
+
+        // Donate
+        snapStart("donate with noop");
+        delta = donateRouter.donate(key, 0, 0, ZERO_BYTES);
+        snapStart("donate with noop");
+    }
+
+    function test_noop_succeedsOnAllActions(uint160 sqrtPriceX96) public {
+        // Assumptions tested in Pool.t.sol
+        sqrtPriceX96 = uint160(bound(sqrtPriceX96, TickMath.MIN_SQRT_RATIO, TickMath.MAX_SQRT_RATIO - 1));
+
+        address payable hookAddr = payable(
+            address(
+                uint160(
+                    Hooks.BEFORE_ADD_LIQUIDITY_FLAG | Hooks.BEFORE_SWAP_FLAG | Hooks.BEFORE_DONATE_FLAG
+                        | Hooks.NO_OP_FLAG
+                )
+            )
+        );
+
+        vm.etch(hookAddr, vm.getDeployedCode("NoOpTestHooks.sol:NoOpTestHooks"));
+
+        (key,) = initPool(currency0, currency1, IHooks(hookAddr), 100, SQRT_RATIO_1_1, ZERO_BYTES);
+
+        uint256 reserveBefore0 = manager.reservesOf(currency0);
+        uint256 reserveBefore1 = manager.reservesOf(currency1);
+
+        // Test add liquidity
+        BalanceDelta delta = modifyLiquidityRouter.modifyLiquidity(
+            key, IPoolManager.ModifyLiquidityParams(-120, 120, 10 ether), ZERO_BYTES
+        );
+
+        assertTrue(delta == BalanceDeltaLibrary.MAXIMUM_DELTA, "Max delta not returned");
+        assertEq(manager.reservesOf(currency0), reserveBefore0);
+        assertEq(manager.reservesOf(currency1), reserveBefore1);
+
+        // Swap
+        IPoolManager.SwapParams memory swapParams =
+            IPoolManager.SwapParams({zeroForOne: true, amountSpecified: 100, sqrtPriceLimitX96: SQRT_RATIO_1_2});
+
+        PoolSwapTest.TestSettings memory testSettings =
+            PoolSwapTest.TestSettings({withdrawTokens: true, settleUsingTransfer: true, currencyAlreadySent: false});
+
+        delta = swapRouter.swap(key, swapParams, testSettings, ZERO_BYTES);
+
+        assertTrue(delta == BalanceDeltaLibrary.MAXIMUM_DELTA, "Max delta not returned");
+        assertEq(manager.reservesOf(currency0), reserveBefore0);
+        assertEq(manager.reservesOf(currency1), reserveBefore1);
+
+        // Donate
+        delta = donateRouter.donate(key, 1 ether, 1 ether, ZERO_BYTES);
+
+        assertTrue(delta == BalanceDeltaLibrary.MAXIMUM_DELTA, "Max delta not returned");
+        assertEq(manager.reservesOf(currency0), reserveBefore0);
+        assertEq(manager.reservesOf(currency1), reserveBefore1);
+    }
+
+    function test_noop_failsOnUninitializedPools(uint160 sqrtPriceX96) public {
+        // Assumptions tested in Pool.t.sol
+        sqrtPriceX96 = uint160(bound(sqrtPriceX96, TickMath.MIN_SQRT_RATIO, TickMath.MAX_SQRT_RATIO - 1));
+
+        address payable hookAddr = payable(
+            address(
+                uint160(
+                    Hooks.BEFORE_ADD_LIQUIDITY_FLAG | Hooks.BEFORE_SWAP_FLAG | Hooks.BEFORE_DONATE_FLAG
+                        | Hooks.NO_OP_FLAG
+                )
+            )
+        );
+
+        vm.etch(hookAddr, vm.getDeployedCode("NoOpTestHooks.sol:NoOpTestHooks"));
+
+        // Modify Position
+        key = PoolKey({currency0: currency0, currency1: currency1, fee: 100, hooks: IHooks(hookAddr), tickSpacing: 10});
+
+        vm.expectRevert(abi.encodeWithSelector(Pool.PoolNotInitialized.selector));
+        BalanceDelta delta = modifyLiquidityRouter.modifyLiquidity(
+            key, IPoolManager.ModifyLiquidityParams(-120, 120, 10 ether), ZERO_BYTES
+        );
+
+        // Swap
+        IPoolManager.SwapParams memory swapParams =
+            IPoolManager.SwapParams({zeroForOne: true, amountSpecified: 100, sqrtPriceLimitX96: SQRT_RATIO_1_2});
+
+        PoolSwapTest.TestSettings memory testSettings =
+            PoolSwapTest.TestSettings({withdrawTokens: true, settleUsingTransfer: true, currencyAlreadySent: false});
+
+        vm.expectRevert(abi.encodeWithSelector(Pool.PoolNotInitialized.selector));
+        delta = swapRouter.swap(key, swapParams, testSettings, ZERO_BYTES);
+
+        // Donate
+        vm.expectRevert(abi.encodeWithSelector(Pool.PoolNotInitialized.selector));
+        delta = donateRouter.donate(key, 1 ether, 1 ether, ZERO_BYTES);
+    }
+
+    function test_noop_failsOnForbiddenFunctions(uint160 sqrtPriceX96) public {
+        // Assumptions tested in Pool.t.sol
+        sqrtPriceX96 = uint160(bound(sqrtPriceX96, TickMath.MIN_SQRT_RATIO, TickMath.MAX_SQRT_RATIO - 1));
+
+        address payable hookAddr = payable(
+            address(
+                uint160(
+                    Hooks.BEFORE_INITIALIZE_FLAG | Hooks.BEFORE_SWAP_FLAG | Hooks.AFTER_SWAP_FLAG
+                        | Hooks.AFTER_ADD_LIQUIDITY_FLAG | Hooks.AFTER_DONATE_FLAG | Hooks.NO_OP_FLAG
+                )
+            )
+        );
+
+        MockHooks impl = new MockHooks();
+        vm.etch(hookAddr, address(impl).code);
+        MockHooks mockHooks = MockHooks(hookAddr);
+
+        key = PoolKey({currency0: currency0, currency1: currency1, fee: 100, hooks: mockHooks, tickSpacing: 10});
+
+        // Fails at beforeInitialize hook when it returns a NoOp
+        mockHooks.setReturnValue(mockHooks.beforeInitialize.selector, Hooks.NO_OP_SELECTOR);
+        vm.expectRevert(Hooks.InvalidHookResponse.selector);
+        initializeRouter.initialize(key, SQRT_RATIO_1_1, ZERO_BYTES);
+
+        // Now we let initialize succeed (so we can test other functions)
+        mockHooks.setReturnValue(mockHooks.beforeInitialize.selector, mockHooks.beforeInitialize.selector);
+        initializeRouter.initialize(key, SQRT_RATIO_1_1, ZERO_BYTES);
+
+        // Fails at afterAddLiquidity hook when it returns a NoOp
+        mockHooks.setReturnValue(mockHooks.afterAddLiquidity.selector, Hooks.NO_OP_SELECTOR);
+        vm.expectRevert(Hooks.InvalidHookResponse.selector);
+        modifyLiquidityRouter.modifyLiquidity(key, LIQ_PARAMS, ZERO_BYTES);
+
+        // Now we let the modify position succeed (so we can test other functions)
+        mockHooks.setReturnValue(mockHooks.afterAddLiquidity.selector, mockHooks.afterAddLiquidity.selector);
+        modifyLiquidityRouter.modifyLiquidity(key, LIQ_PARAMS, ZERO_BYTES);
+
+        // Fails at afterSwap hook when it returns a NoOp
+        mockHooks.setReturnValue(mockHooks.afterSwap.selector, Hooks.NO_OP_SELECTOR);
+        vm.expectRevert(Hooks.InvalidHookResponse.selector);
+        swapRouter.swap(
+            key,
+            IPoolManager.SwapParams({zeroForOne: true, amountSpecified: 100, sqrtPriceLimitX96: SQRT_RATIO_1_2}),
+            PoolSwapTest.TestSettings({withdrawTokens: false, settleUsingTransfer: true, currencyAlreadySent: false}),
+            ZERO_BYTES
+        );
+
+        // Fails at afterDonate hook when it returns a NoOp
+        mockHooks.setReturnValue(mockHooks.afterDonate.selector, Hooks.NO_OP_SELECTOR);
+        vm.expectRevert(Hooks.InvalidHookResponse.selector);
+        donateRouter.donate(key, 100, 100, ZERO_BYTES);
+    }
+
+    function test_noop_failsWithoutNoOpFlag(uint160 sqrtPriceX96) public {
+        // Assumptions tested in Pool.t.sol
+        sqrtPriceX96 = uint160(bound(sqrtPriceX96, TickMath.MIN_SQRT_RATIO, TickMath.MAX_SQRT_RATIO - 1));
+
+        address payable hookAddr = payable(
+            address(uint160(Hooks.BEFORE_ADD_LIQUIDITY_FLAG | Hooks.BEFORE_SWAP_FLAG | Hooks.BEFORE_DONATE_FLAG))
+        );
+
+        MockHooks impl = new MockHooks();
+        vm.etch(hookAddr, address(impl).code);
+        MockHooks mockHooks = MockHooks(hookAddr);
+
+        key = PoolKey({currency0: currency0, currency1: currency1, fee: 100, hooks: mockHooks, tickSpacing: 10});
+        initializeRouter.initialize(key, SQRT_RATIO_1_1, ZERO_BYTES);
+
+        // Fails at beforeAddLiquidity hook when it returns a NoOp but doesnt have permission
+        mockHooks.setReturnValue(mockHooks.beforeAddLiquidity.selector, Hooks.NO_OP_SELECTOR);
+        vm.expectRevert(Hooks.InvalidHookResponse.selector);
+        modifyLiquidityRouter.modifyLiquidity(key, LIQ_PARAMS, ZERO_BYTES);
+
+        // Fails at beforeSwap hook when it returns a NoOp but doesnt have permission
+        mockHooks.setReturnValue(mockHooks.beforeSwap.selector, Hooks.NO_OP_SELECTOR);
+        vm.expectRevert(Hooks.InvalidHookResponse.selector);
+        swapRouter.swap(
+            key,
+            IPoolManager.SwapParams({zeroForOne: true, amountSpecified: 100, sqrtPriceLimitX96: SQRT_RATIO_1_2}),
+            PoolSwapTest.TestSettings({withdrawTokens: false, settleUsingTransfer: true, currencyAlreadySent: false}),
+            ZERO_BYTES
+        );
+
+        // Fails at beforeDonate hook when it returns a NoOp but doesnt have permission
+        mockHooks.setReturnValue(mockHooks.beforeDonate.selector, Hooks.NO_OP_SELECTOR);
+        vm.expectRevert(Hooks.InvalidHookResponse.selector);
+        donateRouter.donate(key, 100, 100, ZERO_BYTES);
+    }
+
     function test_collectProtocolFees_ERC20_returnsAllFeesIf0IsProvidedAsParameter() public {
         uint16 protocolFee = 1028; // 00000100 00000100
         uint256 expectedFees = 7;
@@ -1056,6 +1274,12 @@ contract PoolManagerTest is Test, Deployers, GasSnapshot {
         assertEq(manager.protocolFeesAccrued(nativeCurrency), 0);
     }
 
+    function test_lock_NoOp_gas() public {
+        snapStart("gas overhead of no-op lock");
+        emptyLockRouter.lock();
+        snapEnd();
+    }
+
     function test_lock_EmitsCorrectId() public {
         vm.expectEmit(false, false, false, true);
         emit LockAcquired();
