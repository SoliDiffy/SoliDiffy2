diff --git a/contracts/UniswapV3Pair.sol b/contracts/UniswapV3Pair.sol
index 19be38b6..93c9c823 100644
--- a/contracts/UniswapV3Pair.sol
+++ b/contracts/UniswapV3Pair.sol
@@ -52,8 +52,8 @@ contract UniswapV3Pair is IUniswapV3Pair {
     // the amount of virtual supply active within the current tick, for each fee vote
     uint112[4] public override virtualSupplies;
 
-    FixedPoint.uq144x112 internal price0CumulativeLast; // cumulative (reserve1Virtual / reserve0Virtual) oracle price
-    FixedPoint.uq144x112 internal price1CumulativeLast; // cumulative (reserve0Virtual / reserve1Virtual) oracle price
+    FixedPoint.uq144x112 public price0CumulativeLast; // cumulative (reserve1Virtual / reserve0Virtual) oracle price
+    FixedPoint.uq144x112 public price1CumulativeLast; // cumulative (reserve0Virtual / reserve1Virtual) oracle price
     
     struct TickInfo {
         // fee growth on the _other_ side of this tick (relative to the current tick)
@@ -197,11 +197,20 @@ contract UniswapV3Pair is IUniswapV3Pair {
     }
 
     // update reserves and, on the first interaction per block, price accumulators
-    function _update() internal {
+    function _update() private {
         uint32 blockTimestamp = uint32(block.timestamp); // truncation is desired
         uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired
         if (timeElapsed > 0) {
-            (price0CumulativeLast, price1CumulativeLast) = getCumulativePrices();
+            // TODO these may not be necessary, or we may have to short-circuit if either are true
+            assert(reserve0Virtual != 0);
+            assert(reserve1Virtual != 0);
+            // overflow is desired
+            price0CumulativeLast = FixedPoint.uq144x112(
+                price0CumulativeLast._x + FixedPoint.fraction(reserve1Virtual, reserve0Virtual).mul(timeElapsed)._x
+            );
+            price1CumulativeLast = FixedPoint.uq144x112(
+                price1CumulativeLast._x + FixedPoint.fraction(reserve0Virtual, reserve1Virtual).mul(timeElapsed)._x
+            );
             blockTimestampLast = blockTimestamp;
         }
     }
@@ -218,8 +227,8 @@ contract UniswapV3Pair is IUniswapV3Pair {
 
         // ensure the tick witness is correct
         FixedPoint.uq112x112 memory price = FixedPoint.fraction(amount1, amount0);
-        require(TickMath.getPrice(tick    )._x <= price._x, 'UniswapV3: STARTING_TICK_TOO_LARGE');
-        require(TickMath.getPrice(tick + 1)._x >  price._x, 'UniswapV3: STARTING_TICK_TOO_SMALL');
+        require(TickMath.getRatioAtTick(tick    )._x <= price._x, 'UniswapV3: STARTING_TICK_TOO_LARGE');
+        require(TickMath.getRatioAtTick(tick + 1)._x >  price._x, 'UniswapV3: STARTING_TICK_TOO_SMALL');
 
         // ensure that at a minimum amount of liquidity will be generated
         liquidity = uint112(Babylonian.sqrt(uint(amount0) * amount1));
@@ -316,8 +325,10 @@ contract UniswapV3Pair is IUniswapV3Pair {
         // calculate how much the specified liquidity delta is worth at the lower and upper ticks
         // amount0Lower :> amount0Upper
         // amount1Upper :> amount1Lower
-        (int112 amount0Lower, int112 amount1Lower) = getValueAtPrice(TickMath.getPrice(tickLower), liquidityDelta);
-        (int112 amount0Upper, int112 amount1Upper) = getValueAtPrice(TickMath.getPrice(tickUpper), liquidityDelta);
+        (int112 amount0Lower, int112 amount1Lower) =
+            getValueAtPrice(TickMath.getRatioAtTick(tickLower), liquidityDelta);
+        (int112 amount0Upper, int112 amount1Upper) =
+            getValueAtPrice(TickMath.getRatioAtTick(tickUpper), liquidityDelta);
 
         // regardless of current price, when lower tick is crossed from left to right, amount0Lower should be added
         if (tickLower > TickMath.MIN_TICK) {
@@ -387,13 +398,13 @@ contract UniswapV3Pair is IUniswapV3Pair {
             require(reserve1Virtual >= TOKEN_MIN, 'UniswapV3: INSUFFICIENT_LIQUIDITY');
 
             // get the inclusive lower bound price for the current tick
-            FixedPoint.uq112x112 memory price = TickMath.getPrice(tickCurrent);
+            FixedPoint.uq112x112 memory price = TickMath.getRatioAtTick(tickCurrent);
             // get the current fee
             uint16 fee = getFee();
             // compute the amount of token0 required s.t. the price is ~the lower bound for the current tick
             // TODO adjust this amount (or amount1OutStep) so that we're guaranteed the ratio is as close (or equal)
             // to the lower bound _without_ exceeding it as possible
-            uint112 amount0InRequiredForShift = PriceMath.getTradeToRatio(
+            uint112 amount0InRequiredForShift = PriceMath.getInputToRatio(
                 reserve0Virtual, reserve1Virtual, fee, price.reciprocal()
             );
 
@@ -469,23 +480,4 @@ contract UniswapV3Pair is IUniswapV3Pair {
         if (data.length > 0) IUniswapV3Callee(to).uniswapV3Call(msg.sender, 0, amount1Out, data);
         TransferHelper.safeTransferFrom(token0, msg.sender, address(this), amount0In); // this is different than v2
     }
-
-    // Helper for reading the cumulative price as of the current block
-    function getCumulativePrices() public view returns (
-        FixedPoint.uq144x112 memory price0Cumulative,
-        FixedPoint.uq144x112 memory price1Cumulative
-    ) {
-        uint32 blockTimestamp = uint32(block.timestamp);
-
-        if (blockTimestampLast != blockTimestamp) {
-            uint32 timeElapsed = blockTimestamp - blockTimestampLast;
-            price0Cumulative = FixedPoint.uq144x112(
-                price0CumulativeLast._x + FixedPoint.fraction(reserve1Virtual, reserve0Virtual).mul(timeElapsed)._x
-            );
-
-            price1Cumulative = FixedPoint.uq144x112(
-                price1CumulativeLast._x + FixedPoint.fraction(reserve0Virtual, reserve1Virtual).mul(timeElapsed)._x
-            );
-        }
-    }
 }
