diff --git a/src/ProtocolFees.sol b/src/ProtocolFees.sol
index 3e7263a4..d73d6003 100644
--- a/src/ProtocolFees.sol
+++ b/src/ProtocolFees.sol
@@ -9,12 +9,14 @@ import {ProtocolFeeLibrary} from "./libraries/ProtocolFeeLibrary.sol";
 import {Owned} from "solmate/auth/Owned.sol";
 import {PoolId, PoolIdLibrary} from "./types/PoolId.sol";
 import {Pool} from "./libraries/Pool.sol";
+import {CustomRevert} from "./libraries/CustomRevert.sol";
 
 abstract contract ProtocolFees is IProtocolFees, Owned {
     using CurrencyLibrary for Currency;
     using ProtocolFeeLibrary for uint24;
     using PoolIdLibrary for PoolKey;
     using Pool for Pool.State;
+    using CustomRevert for bytes4;
 
     mapping(Currency currency => uint256) public protocolFeesAccrued;
 
@@ -34,8 +36,8 @@ abstract contract ProtocolFees is IProtocolFees, Owned {
 
     /// @inheritdoc IProtocolFees
     function setProtocolFee(PoolKey memory key, uint24 newProtocolFee) external {
-        if (msg.sender != address(protocolFeeController)) revert InvalidCaller();
-        if (!newProtocolFee.isValidProtocolFee()) revert InvalidProtocolFee();
+        if (msg.sender != address(protocolFeeController)) InvalidCaller.selector.revertWith();
+        if (!newProtocolFee.isValidProtocolFee()) InvalidProtocolFee.selector.revertWith();
         PoolId id = key.toId();
         _getPool(id).setProtocolFee(newProtocolFee);
         emit ProtocolFeeUpdated(id, newProtocolFee);
@@ -46,7 +48,7 @@ abstract contract ProtocolFees is IProtocolFees, Owned {
         external
         returns (uint256 amountCollected)
     {
-        if (msg.sender != address(protocolFeeController)) revert InvalidCaller();
+        if (msg.sender != address(protocolFeeController)) InvalidCaller.selector.revertWith();
 
         amountCollected = (amount == 0) ? protocolFeesAccrued[currency] : amount;
         protocolFeesAccrued[currency] -= amountCollected;
@@ -64,7 +66,7 @@ abstract contract ProtocolFees is IProtocolFees, Owned {
             // note that EIP-150 mandates that calls requesting more than 63/64ths of remaining gas
             // will be allotted no more than this amount, so controllerGasLimit must be set with this
             // in mind.
-            if (gasleft() < controllerGasLimit) revert ProtocolFeeCannotBeFetched();
+            if (gasleft() < controllerGasLimit) ProtocolFeeCannotBeFetched.selector.revertWith();
 
             (bool _success, bytes memory _data) = address(protocolFeeController).call{gas: controllerGasLimit}(
                 abi.encodeWithSelector(IProtocolFeeController.protocolFeeForPool.selector, key)
