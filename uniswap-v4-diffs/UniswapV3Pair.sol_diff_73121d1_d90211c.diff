diff --git a/contracts/UniswapV3Pair.sol b/contracts/UniswapV3Pair.sol
index 06e80ee9..7f388a99 100644
--- a/contracts/UniswapV3Pair.sol
+++ b/contracts/UniswapV3Pair.sol
@@ -6,7 +6,7 @@ pragma experimental ABIEncoderV2;
 import '@uniswap/lib/contracts/libraries/TransferHelper.sol';
 import '@uniswap/lib/contracts/libraries/FixedPoint.sol';
 import '@uniswap/lib/contracts/libraries/Babylonian.sol';
-
+import '@uniswap/lib/contracts/libraries/TickMath.sol';
 
 import './interfaces/IUniswapV3Pair.sol';
 import { Aggregate, AggregateFunctions } from './libraries/AggregateFeeVote.sol';
@@ -16,8 +16,6 @@ import './libraries/SafeMath112.sol';
 import './interfaces/IUniswapV3Factory.sol';
 import './interfaces/IUniswapV3Callee.sol';
 import './libraries/FixedPointExtra.sol';
-import './libraries/TickMath.sol';
-import './libraries/PriceMath.sol';
 
 contract UniswapV3Pair is IUniswapV3Pair {
     using SafeMath for uint;
@@ -309,7 +307,15 @@ contract UniswapV3Pair is IUniswapV3Pair {
         emit SetPosition(msg.sender, liquidity, lowerTick, upperTick, feeVote);
     }
 
+    function getTradeToRatio(uint112 y0, uint112 x0, FixedPoint.uq112x112 memory price, uint112 _lpFee) internal pure returns (uint112) {
+        // todo: clean up this monstrosity, which won't even compile because the stack is too deep
+        // simplification of https://www.wolframalpha.com/input/?i=solve+%28x0+-+x0*%281-g%29*y%2F%28y0+%2B+%281-g%29*y%29%29%2F%28y0+%2B+y%29+%3D+p+for+y
+        // uint112 numerator = price.sqrt().mul112(uint112(Babylonian.sqrt(y0))).mul112(uint112(Babylonian.sqrt(price.mul112(y0).mul112(_lpFee).mul112(_lpFee).div(1000000).add(price.mul112(4 * x0).mul112(1000000 - _lpFee)).decode()))).decode();
+        // uint112 denominator = price.mul112(1000000 - _lpFee).div(1000000).mul112(2).decode();
 
+        // this is just a dummy expression that uses all the variables to silence the linter
+        return price.mul112(y0 + x0 + _lpFee).decode();
+    }
 
     // TODO: implement swap1for0, or integrate it into this
     function swap0for1(uint amountIn, address to, bytes calldata data) external lock {
@@ -324,7 +330,7 @@ contract UniswapV3Pair is IUniswapV3Pair {
         while (amountInLeft > 0) {
             FixedPoint.uq112x112 memory price = TickMath.getPrice(_currentTick);
             // compute how much would need to be traded to get to the next tick down
-            uint112 maxAmount = PriceMath.getTradeToRatio(_reserve0, _reserve1, _lpFee, price);
+            uint112 maxAmount = getTradeToRatio(_reserve0, _reserve1, price, _lpFee);
             uint112 amountInStep = (amountInLeft > maxAmount) ? maxAmount : amountInLeft;
             // execute the sell of amountToTrade
             uint112 adjustedAmountToTrade = amountInStep * (1000000 - _lpFee) / 1000000;
