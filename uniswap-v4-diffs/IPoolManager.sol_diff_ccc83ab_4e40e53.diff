diff --git a/src/interfaces/IPoolManager.sol b/src/interfaces/IPoolManager.sol
index 3a533651..b3b85b8f 100644
--- a/src/interfaces/IPoolManager.sol
+++ b/src/interfaces/IPoolManager.sol
@@ -27,13 +27,13 @@ interface IPoolManager is IProtocolFees, IERC6909Claims, IExtsload, IExttload {
     error ManagerLocked();
 
     /// @notice Pools are limited to type(int16).max tickSpacing in #initialize, to prevent overflow
-    error TickSpacingTooLarge(int24 tickSpacing);
+    error TickSpacingTooLarge();
 
     /// @notice Pools must have a positive non-zero tickSpacing passed to #initialize
-    error TickSpacingTooSmall(int24 tickSpacing);
+    error TickSpacingTooSmall();
 
     /// @notice PoolKey must have currencies where address(currency0) < address(currency1)
-    error CurrenciesOutOfOrderOrEqual(address currency0, address currency1);
+    error CurrenciesOutOfOrderOrEqual();
 
     /// @notice Thrown when a call to updateDynamicLPFee is made by an address that is not the hook,
     /// or on a pool that does not have a dynamic swap fee.
@@ -45,6 +45,9 @@ interface IPoolManager is IProtocolFees, IERC6909Claims, IExtsload, IExttload {
     ///@notice Thrown when native currency is passed to a non native settlement
     error NonZeroNativeValue();
 
+    /// @notice Thrown when `clear` is called with an amount that is not exactly equal to the open currency delta.
+    error MustClearExactPositiveDelta();
+
     /// @notice Emitted when a new pool is initialized
     /// @param id The abi encoded hash of the pool key struct for the new pool
     /// @param currency0 The first currency of the pool by address sort order
@@ -53,12 +56,7 @@ interface IPoolManager is IProtocolFees, IERC6909Claims, IExtsload, IExttload {
     /// @param tickSpacing The minimum number of ticks between initialized ticks
     /// @param hooks The hooks contract address for the pool, or address(0) if none
     event Initialize(
-        PoolId indexed id,
-        Currency indexed currency0,
-        Currency indexed currency1,
-        uint24 fee,
-        int24 tickSpacing,
-        IHooks hooks
+        PoolId id, Currency indexed currency0, Currency indexed currency1, uint24 fee, int24 tickSpacing, IHooks hooks
     );
 
     /// @notice Emitted when a liquidity position is modified
@@ -82,7 +80,7 @@ interface IPoolManager is IProtocolFees, IERC6909Claims, IExtsload, IExttload {
     /// @param fee The swap fee in hundredths of a bip
     event Swap(
         PoolId indexed id,
-        address indexed sender,
+        address sender,
         int128 amount0,
         int128 amount1,
         uint160 sqrtPriceX96,
@@ -97,23 +95,16 @@ interface IPoolManager is IProtocolFees, IERC6909Claims, IExtsload, IExttload {
     /// @notice Returns the constant representing the minimum tickSpacing for an initialized pool key
     function MIN_TICK_SPACING() external view returns (int24);
 
-    /// @notice Writes the current ERC20 balance of the specified currency to transient storage
-    /// This is used to checkpoint balances for the manager and derive deltas for the caller.
-    /// @dev This MUST be called before any ERC20 tokens are sent into the contract.
-    function sync(Currency currency) external returns (uint256 balance);
+    /// @notice All operations go through this function
+    /// @param data Any data to pass to the callback, via `IUnlockCallback(msg.sender).unlockCallback(data)`
+    /// @return The data returned by the call to `IUnlockCallback(msg.sender).unlockCallback(data)`
+    function unlock(bytes calldata data) external returns (bytes memory);
 
     /// @notice Initialize the state for a given pool ID
     function initialize(PoolKey memory key, uint160 sqrtPriceX96, bytes calldata hookData)
         external
         returns (int24 tick);
 
-    /// @notice All interactions on the contract that account deltas require unlocking. A caller that calls `unlock` must implement
-    /// `IUnlockCallback(msg.sender).unlockCallback(data)`, where they interact with the remaining functions on this contract.
-    /// @dev The only functions callable without an unlocking are `initialize` and `updateDynamicLPFee`
-    /// @param data Any data to pass to the callback, via `IUnlockCallback(msg.sender).unlockCallback(data)`
-    /// @return The data returned by the call to `IUnlockCallback(msg.sender).unlockCallback(data)`
-    function unlock(bytes calldata data) external returns (bytes memory);
-
     struct ModifyLiquidityParams {
         // the lower and upper tick of the position
         int24 tickLower;
@@ -133,7 +124,7 @@ interface IPoolManager is IProtocolFees, IERC6909Claims, IExtsload, IExttload {
     /// @return feeDelta The balance delta of the fees generated in the liquidity range. Returned for informational purposes.
     function modifyLiquidity(PoolKey memory key, ModifyLiquidityParams memory params, bytes calldata hookData)
         external
-        returns (BalanceDelta callerDelta, BalanceDelta feeDelta);
+        returns (BalanceDelta, BalanceDelta);
 
     struct SwapParams {
         bool zeroForOne;
@@ -151,26 +142,37 @@ interface IPoolManager is IProtocolFees, IERC6909Claims, IExtsload, IExttload {
     /// the hook may alter the swap input/output. Integrators should perform checks on the returned swapDelta.
     function swap(PoolKey memory key, SwapParams memory params, bytes calldata hookData)
         external
-        returns (BalanceDelta swapDelta);
+        returns (BalanceDelta);
 
     /// @notice Donate the given currency amounts to the pool with the given pool key
     function donate(PoolKey memory key, uint256 amount0, uint256 amount1, bytes calldata hookData)
         external
         returns (BalanceDelta);
 
+    /// @notice Writes the current ERC20 balance of the specified currency to transient storage
+    /// This is used to checkpoint balances for the manager and derive deltas for the caller.
+    /// @dev This MUST be called before any ERC20 tokens are sent into the contract.
+    function sync(Currency currency) external returns (uint256 balance);
+
     /// @notice Called by the user to net out some value owed to the user
     /// @dev Can also be used as a mechanism for _free_ flash loans
     function take(Currency currency, address to, uint256 amount) external;
 
+    /// @notice Called by the user to pay what is owed
+    function settle(Currency currency) external payable returns (uint256 paid);
+
+    /// @notice WARNING - Any currency that is cleared, will be non-retreivable, and locked in the contract permanently.
+    /// A call to clear will zero out a positive balance WITHOUT a corresponding transfer.
+    /// @dev This could be used to clear a balance that is considered dust.
+    /// Additionally, the amount must be the exact positive balance. This is to enforce that the caller is aware of the amount being cleared.
+    function clear(Currency currency, uint256 amount) external;
+
     /// @notice Called by the user to move value into ERC6909 balance
     function mint(address to, uint256 id, uint256 amount) external;
 
     /// @notice Called by the user to move value from ERC6909 balance
     function burn(address from, uint256 id, uint256 amount) external;
 
-    /// @notice Called by the user to pay what is owed
-    function settle(Currency token) external payable returns (uint256 paid);
-
     /// @notice Updates the pools lp fees for the a pool that has enabled dynamic lp fees.
     function updateDynamicLPFee(PoolKey memory key, uint24 newDynamicLPFee) external;
 }
