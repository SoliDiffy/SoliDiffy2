diff --git a/contracts/UniswapV3Pair.sol b/contracts/UniswapV3Pair.sol
index 0242e785..8ecb3846 100644
--- a/contracts/UniswapV3Pair.sol
+++ b/contracts/UniswapV3Pair.sol
@@ -22,12 +22,12 @@ contract UniswapV3Pair is IUniswapV3Pair {
     // Number of fee options
     uint8 public constant override NUM_FEE_OPTIONS = 6;
 
-    // list of fee options expressed as bips
-    // uint16 because the maximum value is 10_000
+    // list of fee options expressed as pips
+    // uint24 since the maximum value is 1_000_000 which exceeds 2^16
     // options are 0.05%, 0.10%, 0.30%, 0.60%, 1.00%, 2.00%
     // ideally this would be a constant array, but constant arrays are not supported in solidity
-    function FEE_OPTIONS() public pure returns (uint16[NUM_FEE_OPTIONS] memory) {
-        return [uint16(5), 10, 30, 60, 100, 200];
+    function FEE_OPTIONS() public pure returns (uint24[NUM_FEE_OPTIONS] memory) {
+        return [uint24(500), 1000, 3000, 6000, 10000, 20000];
     }
 
     uint112 public constant override LIQUIDITY_MIN = 1000;
@@ -52,7 +52,7 @@ contract UniswapV3Pair is IUniswapV3Pair {
 
     // the current fee (gets set by the first swap or setPosition/initialize in a block)
     // this is stored to protect liquidity providers from add/swap/remove sandwiching attacks
-    uint16 public feeLast;
+    uint24 public feeLast;
 
     // the amount of virtual supply active within the current tick, for each fee vote
     uint112[NUM_FEE_OPTIONS] public override virtualSupplies;
@@ -115,8 +115,8 @@ contract UniswapV3Pair is IUniswapV3Pair {
             virtualSupplies[5];
     }
 
-    // find the median fee vote, and return the fee in bips
-    function getFee() public view override returns (uint16 fee) {
+    // find the median fee vote, and return the fee in pips
+    function getFee() public view override returns (uint24 fee) {
         uint112 virtualSupplyCumulative;
         // load all virtual supplies into memory
         uint112[NUM_FEE_OPTIONS] memory virtualSupplies_ = [
@@ -133,7 +133,7 @@ contract UniswapV3Pair is IUniswapV3Pair {
             virtualSupplies_[3] +
             virtualSupplies_[4] +
             virtualSupplies_[5]) / 2;
-        uint16[NUM_FEE_OPTIONS] memory feeOptions = FEE_OPTIONS();
+        uint24[NUM_FEE_OPTIONS] memory feeOptions = FEE_OPTIONS();
         for (uint8 feeVoteIndex = 0; feeVoteIndex < NUM_FEE_OPTIONS - 1; feeVoteIndex++) {
             virtualSupplyCumulative += virtualSupplies_[feeVoteIndex];
             if (virtualSupplyCumulative >= threshold) {
@@ -329,7 +329,7 @@ contract UniswapV3Pair is IUniswapV3Pair {
     }
 
     // note: this function can cause the price to change
-    function updateReservesAndVirtualSupply(int112 liquidityDelta, uint16 feeVote)
+    function updateReservesAndVirtualSupply(int112 liquidityDelta, uint24 feeVote)
         internal
         returns (int112 amount0, int112 amount1)
     {
@@ -528,7 +528,7 @@ contract UniswapV3Pair is IUniswapV3Pair {
         _update(); // update the oracle and feeLast
 
         // use the fee from the previous block as the floor
-        uint16 fee = feeLast;
+        uint24 fee = feeLast;
         int16 tick = tickCurrent;
 
         uint112 amountInRemaining = params.amountIn;
@@ -544,7 +544,7 @@ contract UniswapV3Pair is IUniswapV3Pair {
             step.nextPrice = params.zeroForOne ? TickMath.getRatioAtTick(tick) : TickMath.getRatioAtTick(tick + 1);
 
             // adjust the fee we will use if the current fee is greater than the stored fee to protect liquidity providers
-            uint16 currentFee = getFee();
+            uint24 currentFee = getFee();
             if (fee < currentFee) fee = currentFee;
 
             (uint112 reserveInVirtual, uint112 reserveOutVirtual) = params.zeroForOne
