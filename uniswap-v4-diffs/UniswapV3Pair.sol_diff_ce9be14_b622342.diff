diff --git a/contracts/UniswapV3Pair.sol b/contracts/UniswapV3Pair.sol
index 0e84126f..481f2eb1 100644
--- a/contracts/UniswapV3Pair.sol
+++ b/contracts/UniswapV3Pair.sol
@@ -586,17 +586,13 @@ contract UniswapV3Pair is IUniswapV3Pair {
                         PriceMath.LP_FEE_BASE))
                     .toUint112();
 
-                // TODO we should ensure that step.amountOut + 1 always results in a price exceeding the target
-
                 // calculate the maximum output amount s.t. the reserves price is guaranteed to be as close as possible
                 // to the target price _without_ exceeding it
-                uint112 reserveInVirtualNext = (uint256(reserveInVirtual) + step.amountIn).toUint112();
-                uint256 reserveOutVirtualThreshold = PriceMath.getReserveOutThreshold(
-                    params.zeroForOne,
-                    reserveInVirtualNext,
-                    step.nextPrice
-                );
-                uint112 amountOutMaximum = reserveOutVirtual.sub(reserveOutVirtualThreshold).toUint112();
+                uint112 reserveInVirtualNext = (uint256(reserveInVirtual) + amountInRequiredForShift).toUint112();
+                uint256 reserveOutVirtualNext = params.zeroForOne
+                    ? FullMath.mulDiv(reserveInVirtualNext, step.nextPrice._x, uint256(1) << 112)
+                    : FixedPoint.encode(reserveInVirtualNext)._x / step.nextPrice._x;
+                uint112 amountOutMaximum = reserveOutVirtual.sub(reserveOutVirtualNext).toUint112();
                 step.amountOut = Math.min(step.amountOut, amountOutMaximum).toUint112();
 
                 if (params.zeroForOne) {
@@ -607,17 +603,6 @@ contract UniswapV3Pair is IUniswapV3Pair {
                     reserve1Virtual = (uint256(reserve1Virtual) + step.amountIn).toUint112();
                 }
 
-                // TODO add this back when we know its working
-                // TODO remove this eventually, it's meant to ensure our overshoot compensation logic is correct
-                // {
-                //     FixedPoint.uq112x112 memory priceNext = FixedPoint.fraction(reserve1Virtual, reserve0Virtual);
-                //     if (params.zeroForOne) {
-                //         assert(priceNext._x >= step.nextPrice._x);
-                //     } else {
-                //         assert(priceNext._x <= step.nextPrice._x);                    
-                //     }
-                // }
-
                 amountInRemaining = amountInRemaining.sub(step.amountIn).toUint112();
                 amountOut = (uint256(amountOut) + step.amountOut).toUint112();
             }
@@ -658,21 +643,21 @@ contract UniswapV3Pair is IUniswapV3Pair {
 
                     // TODO remove this eventually, it's meant to show the direction of rounding
                     {
-                    FixedPoint.uq112x112 memory priceNext = FixedPoint.fraction(reserve1Virtual, reserve0Virtual);
-                    if (params.zeroForOne) {
-                        if (token1VirtualDelta > 0) {
-                            assert(priceNext._x <= step.nextPrice._x); // this should be ok, we're moving left
-                        } else {
-                            // TODO figure out what to do here
-                        }
-                    } else {
-                        if (token1VirtualDelta > 0) {
-                            assert(priceNext._x >= step.nextPrice._x); // this should be ok, we're moving right
+                        FixedPoint.uq112x112 memory priceNext = FixedPoint.fraction(reserve1Virtual, reserve0Virtual);
+                        if (params.zeroForOne) {
+                            if (token1VirtualDelta > 0) {
+                                assert(priceNext._x <= step.nextPrice._x); // this should be ok, we're moving left
+                            } else {
+                                require(priceNext._x == step.nextPrice._x, 'UniswapV3: RIGHT_IS_WRONG');
+                            }
                         } else {
-                            // TODO figure out what to do here
+                            if (token1VirtualDelta > 0) {
+                                assert(priceNext._x >= step.nextPrice._x); // this should be ok, we're moving right
+                            } else {
+                                require(priceNext._x == step.nextPrice._x, 'UniswapV3: LEFT_IS_NOT_RIGHT');
+                            }
                         }
                     }
-                    }
 
                     // update virtual supply
                     // TODO it may be possible to squeeze out a bit more precision under certain circumstances by:
