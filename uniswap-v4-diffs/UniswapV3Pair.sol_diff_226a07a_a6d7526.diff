diff --git a/contracts/UniswapV3Pair.sol b/contracts/UniswapV3Pair.sol
index af6269d8..2b31ebfe 100644
--- a/contracts/UniswapV3Pair.sol
+++ b/contracts/UniswapV3Pair.sol
@@ -215,6 +215,27 @@ contract UniswapV3Pair is IUniswapV3Pair {
         emit Edit(msg.sender, int112(liquidity), MIN_TICK, MAX_TICK);
     }
 
+    // // this low-level function should be called from a contract which performs important safety checks
+    // function burn(address to, uint liquidity) external override lock returns (uint amount0, uint amount1) {
+    //     (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings
+    //     address _token0 = token0;                                // gas savings
+    //     address _token1 = token1;                                // gas savings
+
+    //     bool feeOn = _mintFee(_reserve0, _reserve1);
+    //     uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee
+    //     uint amount0 = liquidity.mul(uint(_reserve0)) / _totalSupply;
+    //     uint amount1 = liquidity.mul(uint(_reserve1)) / _totalSupply;
+    //     require(amount0 > 0 && amount1 > 0, 'UniswapV3: INSUFFICIENT_LIQUIDITY_BURNED');
+    //     _burn(msg.sender, liquidity);
+    //     _reserve0 -= amount0;
+    //     _reserve1 -= amount1;
+    //     _update(_reserve0, _reserve1);
+    //     TransferHelper.safeTransfer(_token0, to, amount0);
+    //     TransferHelper.safeTransfer(_token1, to, amount1);
+    //     if (feeOn) kLast = uint(_reserve0).mul(_reserve1); // reserve0 and reserve1 are up-to-date
+    //     emit Burn(msg.sender, amount0, amount1, to);
+    // }
+
     // add or remove a specified amount of liquidity from a specified range
     // TODO: this will not allow you to handle liquidity from fees; those may need a separate function
     function edit(int112 liquidity, int16 lowerTick, int16 upperTick) external override lock {
