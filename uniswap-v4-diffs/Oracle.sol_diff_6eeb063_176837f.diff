diff --git a/contracts/libraries/Oracle.sol b/contracts/libraries/Oracle.sol
index 7deb121e..88f9e4b2 100644
--- a/contracts/libraries/Oracle.sol
+++ b/contracts/libraries/Oracle.sol
@@ -1,5 +1,5 @@
 // SPDX-License-Identifier: BUSL-1.1
-pragma solidity ^0.8.9;
+pragma solidity >=0.5.0;
 
 /// @title Oracle
 /// @notice Provides price and liquidity data useful for a wide variety of system designs
@@ -33,17 +33,15 @@ library Oracle {
         int24 tick,
         uint128 liquidity
     ) private pure returns (Observation memory) {
-        unchecked {
-            uint32 delta = blockTimestamp - last.blockTimestamp;
-            return
-                Observation({
-                    blockTimestamp: blockTimestamp,
-                    tickCumulative: last.tickCumulative + int56(tick) * int56(uint56(delta)),
-                    secondsPerLiquidityCumulativeX128: last.secondsPerLiquidityCumulativeX128 +
-                        ((uint160(delta) << 128) / (liquidity > 0 ? liquidity : 1)),
-                    initialized: true
-                });
-        }
+        uint32 delta = blockTimestamp - last.blockTimestamp;
+        return
+            Observation({
+                blockTimestamp: blockTimestamp,
+                tickCumulative: last.tickCumulative + int56(tick) * delta,
+                secondsPerLiquidityCumulativeX128: last.secondsPerLiquidityCumulativeX128 +
+                    ((uint160(delta) << 128) / (liquidity > 0 ? liquidity : 1)),
+                initialized: true
+            });
     }
 
     /// @notice Initialize the oracle array by writing the first slot. Called once for the lifecycle of the observations array
@@ -86,22 +84,20 @@ library Oracle {
         uint16 cardinality,
         uint16 cardinalityNext
     ) internal returns (uint16 indexUpdated, uint16 cardinalityUpdated) {
-        unchecked {
-            Observation memory last = self[index];
-
-            // early return if we've already written an observation this block
-            if (last.blockTimestamp == blockTimestamp) return (index, cardinality);
+        Observation memory last = self[index];
 
-            // if the conditions are right, we can bump the cardinality
-            if (cardinalityNext > cardinality && index == (cardinality - 1)) {
-                cardinalityUpdated = cardinalityNext;
-            } else {
-                cardinalityUpdated = cardinality;
-            }
+        // early return if we've already written an observation this block
+        if (last.blockTimestamp == blockTimestamp) return (index, cardinality);
 
-            indexUpdated = (index + 1) % cardinalityUpdated;
-            self[indexUpdated] = transform(last, blockTimestamp, tick, liquidity);
+        // if the conditions are right, we can bump the cardinality
+        if (cardinalityNext > cardinality && index == (cardinality - 1)) {
+            cardinalityUpdated = cardinalityNext;
+        } else {
+            cardinalityUpdated = cardinality;
         }
+
+        indexUpdated = (index + 1) % cardinalityUpdated;
+        self[indexUpdated] = transform(last, blockTimestamp, tick, liquidity);
     }
 
     /// @notice Prepares the oracle array to store up to `next` observations
@@ -114,15 +110,13 @@ library Oracle {
         uint16 current,
         uint16 next
     ) internal returns (uint16) {
-        unchecked {
-            require(current > 0, 'I');
-            // no-op if the passed next value isn't greater than the current next value
-            if (next <= current) return current;
-            // store in each slot to prevent fresh SSTOREs in swaps
-            // this data will not be used because the initialized boolean is still false
-            for (uint16 i = current; i < next; i++) self[i].blockTimestamp = 1;
-            return next;
-        }
+        require(current > 0, 'I');
+        // no-op if the passed next value isn't greater than the current next value
+        if (next <= current) return current;
+        // store in each slot to prevent fresh SSTOREs in swaps
+        // this data will not be used because the initialized boolean is still false
+        for (uint16 i = current; i < next; i++) self[i].blockTimestamp = 1;
+        return next;
     }
 
     /// @notice comparator for 32-bit timestamps
@@ -130,21 +124,19 @@ library Oracle {
     /// @param time A timestamp truncated to 32 bits
     /// @param a A comparison timestamp from which to determine the relative position of `time`
     /// @param b From which to determine the relative position of `time`
-    /// @return Whether `a` is chronologically <= `b`
+    /// @return bool Whether `a` is chronologically <= `b`
     function lte(
         uint32 time,
         uint32 a,
         uint32 b
     ) private pure returns (bool) {
-        unchecked {
-            // if there hasn't been overflow, no need to adjust
-            if (a <= time && b <= time) return a <= b;
+        // if there hasn't been overflow, no need to adjust
+        if (a <= time && b <= time) return a <= b;
 
-            uint256 aAdjusted = a > time ? a : a + 2**32;
-            uint256 bAdjusted = b > time ? b : b + 2**32;
+        uint256 aAdjusted = a > time ? a : a + 2**32;
+        uint256 bAdjusted = b > time ? b : b + 2**32;
 
-            return aAdjusted <= bAdjusted;
-        }
+        return aAdjusted <= bAdjusted;
     }
 
     /// @notice Fetches the observations beforeOrAt and atOrAfter a target, i.e. where [beforeOrAt, atOrAfter] is satisfied.
@@ -165,31 +157,29 @@ library Oracle {
         uint16 index,
         uint16 cardinality
     ) private view returns (Observation memory beforeOrAt, Observation memory atOrAfter) {
-        unchecked {
-            uint256 l = (index + 1) % cardinality; // oldest observation
-            uint256 r = l + cardinality - 1; // newest observation
-            uint256 i;
-            while (true) {
-                i = (l + r) / 2;
+        uint256 l = (index + 1) % cardinality; // oldest observation
+        uint256 r = l + cardinality - 1; // newest observation
+        uint256 i;
+        while (true) {
+            i = (l + r) / 2;
 
-                beforeOrAt = self[i % cardinality];
+            beforeOrAt = self[i % cardinality];
 
-                // we've landed on an uninitialized tick, keep searching higher (more recently)
-                if (!beforeOrAt.initialized) {
-                    l = i + 1;
-                    continue;
-                }
+            // we've landed on an uninitialized tick, keep searching higher (more recently)
+            if (!beforeOrAt.initialized) {
+                l = i + 1;
+                continue;
+            }
 
-                atOrAfter = self[(i + 1) % cardinality];
+            atOrAfter = self[(i + 1) % cardinality];
 
-                bool targetAtOrAfter = lte(time, beforeOrAt.blockTimestamp, target);
+            bool targetAtOrAfter = lte(time, beforeOrAt.blockTimestamp, target);
 
-                // check if we've found the answer!
-                if (targetAtOrAfter && lte(time, target, atOrAfter.blockTimestamp)) break;
+            // check if we've found the answer!
+            if (targetAtOrAfter && lte(time, target, atOrAfter.blockTimestamp)) break;
 
-                if (!targetAtOrAfter) r = i - 1;
-                else l = i + 1;
-            }
+            if (!targetAtOrAfter) r = i - 1;
+            else l = i + 1;
         }
     }
 
@@ -214,31 +204,29 @@ library Oracle {
         uint128 liquidity,
         uint16 cardinality
     ) private view returns (Observation memory beforeOrAt, Observation memory atOrAfter) {
-        unchecked {
-            // optimistically set before to the newest observation
-            beforeOrAt = self[index];
+        // optimistically set before to the newest observation
+        beforeOrAt = self[index];
 
-            // if the target is chronologically at or after the newest observation, we can early return
-            if (lte(time, beforeOrAt.blockTimestamp, target)) {
-                if (beforeOrAt.blockTimestamp == target) {
-                    // if newest observation equals target, we're in the same block, so we can ignore atOrAfter
-                    return (beforeOrAt, atOrAfter);
-                } else {
-                    // otherwise, we need to transform
-                    return (beforeOrAt, transform(beforeOrAt, target, tick, liquidity));
-                }
+        // if the target is chronologically at or after the newest observation, we can early return
+        if (lte(time, beforeOrAt.blockTimestamp, target)) {
+            if (beforeOrAt.blockTimestamp == target) {
+                // if newest observation equals target, we're in the same block, so we can ignore atOrAfter
+                return (beforeOrAt, atOrAfter);
+            } else {
+                // otherwise, we need to transform
+                return (beforeOrAt, transform(beforeOrAt, target, tick, liquidity));
             }
+        }
 
-            // now, set before to the oldest observation
-            beforeOrAt = self[(index + 1) % cardinality];
-            if (!beforeOrAt.initialized) beforeOrAt = self[0];
+        // now, set before to the oldest observation
+        beforeOrAt = self[(index + 1) % cardinality];
+        if (!beforeOrAt.initialized) beforeOrAt = self[0];
 
-            // ensure that the target is chronologically at or after the oldest observation
-            require(lte(time, beforeOrAt.blockTimestamp, target), 'OLD');
+        // ensure that the target is chronologically at or after the oldest observation
+        require(lte(time, beforeOrAt.blockTimestamp, target), 'OLD');
 
-            // if we've reached this point, we have to binary search
-            return binarySearch(self, time, target, index, cardinality);
-        }
+        // if we've reached this point, we have to binary search
+        return binarySearch(self, time, target, index, cardinality);
     }
 
     /// @dev Reverts if an observation at or before the desired observation timestamp does not exist.
@@ -263,48 +251,45 @@ library Oracle {
         uint128 liquidity,
         uint16 cardinality
     ) internal view returns (int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128) {
-        unchecked {
-            if (secondsAgo == 0) {
-                Observation memory last = self[index];
-                if (last.blockTimestamp != time) last = transform(last, time, tick, liquidity);
-                return (last.tickCumulative, last.secondsPerLiquidityCumulativeX128);
-            }
+        if (secondsAgo == 0) {
+            Observation memory last = self[index];
+            if (last.blockTimestamp != time) last = transform(last, time, tick, liquidity);
+            return (last.tickCumulative, last.secondsPerLiquidityCumulativeX128);
+        }
 
-            uint32 target = time - secondsAgo;
+        uint32 target = time - secondsAgo;
 
-            (Observation memory beforeOrAt, Observation memory atOrAfter) = getSurroundingObservations(
-                self,
-                time,
-                target,
-                tick,
-                index,
-                liquidity,
-                cardinality
-            );
+        (Observation memory beforeOrAt, Observation memory atOrAfter) = getSurroundingObservations(
+            self,
+            time,
+            target,
+            tick,
+            index,
+            liquidity,
+            cardinality
+        );
 
-            if (target == beforeOrAt.blockTimestamp) {
-                // we're at the left boundary
-                return (beforeOrAt.tickCumulative, beforeOrAt.secondsPerLiquidityCumulativeX128);
-            } else if (target == atOrAfter.blockTimestamp) {
-                // we're at the right boundary
-                return (atOrAfter.tickCumulative, atOrAfter.secondsPerLiquidityCumulativeX128);
-            } else {
-                // we're in the middle
-                uint32 observationTimeDelta = atOrAfter.blockTimestamp - beforeOrAt.blockTimestamp;
-                uint32 targetDelta = target - beforeOrAt.blockTimestamp;
-                return (
-                    beforeOrAt.tickCumulative +
-                        ((atOrAfter.tickCumulative - beforeOrAt.tickCumulative) / int56(uint56(observationTimeDelta))) *
-                        int56(uint56(targetDelta)),
-                    beforeOrAt.secondsPerLiquidityCumulativeX128 +
-                        uint160(
-                            (uint256(
-                                atOrAfter.secondsPerLiquidityCumulativeX128 -
-                                    beforeOrAt.secondsPerLiquidityCumulativeX128
-                            ) * targetDelta) / observationTimeDelta
-                        )
-                );
-            }
+        if (target == beforeOrAt.blockTimestamp) {
+            // we're at the left boundary
+            return (beforeOrAt.tickCumulative, beforeOrAt.secondsPerLiquidityCumulativeX128);
+        } else if (target == atOrAfter.blockTimestamp) {
+            // we're at the right boundary
+            return (atOrAfter.tickCumulative, atOrAfter.secondsPerLiquidityCumulativeX128);
+        } else {
+            // we're in the middle
+            uint32 observationTimeDelta = atOrAfter.blockTimestamp - beforeOrAt.blockTimestamp;
+            uint32 targetDelta = target - beforeOrAt.blockTimestamp;
+            return (
+                beforeOrAt.tickCumulative +
+                    ((atOrAfter.tickCumulative - beforeOrAt.tickCumulative) / observationTimeDelta) *
+                    targetDelta,
+                beforeOrAt.secondsPerLiquidityCumulativeX128 +
+                    uint160(
+                        (uint256(
+                            atOrAfter.secondsPerLiquidityCumulativeX128 - beforeOrAt.secondsPerLiquidityCumulativeX128
+                        ) * targetDelta) / observationTimeDelta
+                    )
+            );
         }
     }
 
@@ -328,22 +313,20 @@ library Oracle {
         uint128 liquidity,
         uint16 cardinality
     ) internal view returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s) {
-        unchecked {
-            require(cardinality > 0, 'I');
+        require(cardinality > 0, 'I');
 
-            tickCumulatives = new int56[](secondsAgos.length);
-            secondsPerLiquidityCumulativeX128s = new uint160[](secondsAgos.length);
-            for (uint256 i = 0; i < secondsAgos.length; i++) {
-                (tickCumulatives[i], secondsPerLiquidityCumulativeX128s[i]) = observeSingle(
-                    self,
-                    time,
-                    secondsAgos[i],
-                    tick,
-                    index,
-                    liquidity,
-                    cardinality
-                );
-            }
+        tickCumulatives = new int56[](secondsAgos.length);
+        secondsPerLiquidityCumulativeX128s = new uint160[](secondsAgos.length);
+        for (uint256 i = 0; i < secondsAgos.length; i++) {
+            (tickCumulatives[i], secondsPerLiquidityCumulativeX128s[i]) = observeSingle(
+                self,
+                time,
+                secondsAgos[i],
+                tick,
+                index,
+                liquidity,
+                cardinality
+            );
         }
     }
 }
