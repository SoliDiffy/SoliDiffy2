diff --git a/contracts/UniswapV3Pair.sol b/contracts/UniswapV3Pair.sol
index 0088acd9..241d12cd 100644
--- a/contracts/UniswapV3Pair.sol
+++ b/contracts/UniswapV3Pair.sol
@@ -32,6 +32,7 @@ contract UniswapV3Pair is IUniswapV3Pair {
     using SafeCast for int256;
     using SafeCast for uint256;
     using MixedSafeMath for uint128;
+    using FixedPoint128 for FixedPoint128.uq128x128;
     using SpacedTickBitmap for mapping(int16 => uint256);
     using Tick for mapping(int24 => Tick.Info);
 
@@ -63,7 +64,7 @@ contract UniswapV3Pair is IUniswapV3Pair {
 
     struct Slot0 {
         // the current price
-        uint160 sqrtPriceCurrent;
+        FixedPoint96.uq64x96 sqrtPriceCurrent;
         // the last block timestamp where the tick accumulator was updated
         uint32 blockTimestampLast;
         // the tick accumulator, i.e. tick * time elapsed since the pair was first initialized
@@ -76,8 +77,12 @@ contract UniswapV3Pair is IUniswapV3Pair {
 
     Slot0 public override slot0;
 
-    // current in-range liquidity
-    uint128 public override liquidityCurrent;
+    struct Slot1 {
+        // current in-range liquidity
+        uint128 liquidityCurrent;
+    }
+
+    Slot1 public override slot1;
 
     address public override feeTo;
 
@@ -85,8 +90,8 @@ contract UniswapV3Pair is IUniswapV3Pair {
     mapping(int16 => uint256) public override tickBitmap;
 
     // fee growth per unit of liquidity
-    uint256 public override feeGrowthGlobal0;
-    uint256 public override feeGrowthGlobal1;
+    FixedPoint128.uq128x128 public override feeGrowthGlobal0;
+    FixedPoint128.uq128x128 public override feeGrowthGlobal1;
 
     // accumulated protocol fees
     uint256 public override feeToFees0;
@@ -97,8 +102,8 @@ contract UniswapV3Pair is IUniswapV3Pair {
     struct Position {
         uint128 liquidity;
         // fee growth per unit of liquidity as of the last modification
-        uint256 feeGrowthInside0Last;
-        uint256 feeGrowthInside1Last;
+        FixedPoint128.uq128x128 feeGrowthInside0Last;
+        FixedPoint128.uq128x128 feeGrowthInside1Last;
         // the fees owed to the position owner in token0/token1
         uint256 feesOwed0;
         uint256 feesOwed1;
@@ -189,12 +194,12 @@ contract UniswapV3Pair is IUniswapV3Pair {
 
     function initialize(uint160 sqrtPrice, bytes calldata data) external override {
         Slot0 memory _slot0 = slot0;
-        require(_slot0.sqrtPriceCurrent == 0, 'AI');
+        require(_slot0.sqrtPriceCurrent._x == 0, 'AI');
 
         _slot0 = Slot0({
             blockTimestampLast: _blockTimestamp(),
             tickCumulativeLast: 0,
-            sqrtPriceCurrent: sqrtPrice,
+            sqrtPriceCurrent: FixedPoint96.uq64x96(sqrtPrice),
             unlockedAndPriceBit: 1
         });
 
@@ -236,14 +241,22 @@ contract UniswapV3Pair is IUniswapV3Pair {
         require(tickInfoLower.liquidityGross <= MAX_LIQUIDITY_GROSS_PER_TICK, 'LOL');
         require(tickInfoUpper.liquidityGross <= MAX_LIQUIDITY_GROSS_PER_TICK, 'LOU');
 
-        (uint256 feeGrowthInside0, uint256 feeGrowthInside1) =
+        (FixedPoint128.uq128x128 memory feeGrowthInside0, FixedPoint128.uq128x128 memory feeGrowthInside1) =
             tickInfos.getFeeGrowthInside(tickLower, tickUpper, tick, feeGrowthGlobal0, feeGrowthGlobal1);
 
         // calculate accumulated fees
         uint256 feesOwed0 =
-            FullMath.mulDiv(feeGrowthInside0 - position.feeGrowthInside0Last, position.liquidity, FixedPoint128.Q128);
+            FullMath.mulDiv(
+                feeGrowthInside0._x - position.feeGrowthInside0Last._x,
+                position.liquidity,
+                FixedPoint128.Q128
+            );
         uint256 feesOwed1 =
-            FullMath.mulDiv(feeGrowthInside1 - position.feeGrowthInside1Last, position.liquidity, FixedPoint128.Q128);
+            FullMath.mulDiv(
+                feeGrowthInside1._x - position.feeGrowthInside1Last._x,
+                position.liquidity,
+                FixedPoint128.Q128
+            );
 
         // collect protocol fee, if on
         if (feeTo != address(0)) {
@@ -403,7 +416,7 @@ contract UniswapV3Pair is IUniswapV3Pair {
             );
 
             // downcasting is safe because of gross liquidity checks in the _updatePosition call
-            liquidityCurrent = uint128(liquidityCurrent.addi(params.liquidityDelta));
+            slot1.liquidityCurrent = uint128(slot1.liquidityCurrent.addi(params.liquidityDelta));
         } else {
             // the current price is above the passed range, so liquidity can only become in range by crossing from right
             // to left, at which point we need _more_ token1 (it's becoming more valuable) so the user must provide it
@@ -419,15 +432,15 @@ contract UniswapV3Pair is IUniswapV3Pair {
         // how much is being swapped in (positive), or requested out (negative)
         int256 amountSpecified;
         // the max/min price that the pair will end up at after the swap
-        uint160 sqrtPriceLimit;
+        FixedPoint96.uq64x96 sqrtPriceLimit;
         // the address that receives amount out
         address recipient;
         // the data to send in the callback
         bytes data;
         // the value of slot0 at the beginning of the swap
         Slot0 slot0Start;
-        // the value of liquidityCurrent at the beginning of the swap
-        uint128 liquidityStart;
+        // the value of slot1 at the beginning of the swap
+        Slot1 slot1Start;
         // the tick at the beginning of the swap
         int24 tickStart;
         // the timestamp of the current block
@@ -441,26 +454,26 @@ contract UniswapV3Pair is IUniswapV3Pair {
         // the amount already swapped out/in of the output/input asset
         int256 amountCalculated;
         // current sqrt(price)
-        uint160 sqrtPrice;
+        FixedPoint96.uq64x96 sqrtPrice;
         // whether the price is at the lower tickCurrent boundary and a tick transition has already occurred
         bool priceBit;
         // the tick associated with the current price
         int24 tick;
         // the global fee growth of the input token
-        uint256 feeGrowthGlobal;
+        FixedPoint128.uq128x128 feeGrowthGlobal;
         // the current liquidity in range
         uint128 liquidity;
     }
 
     struct StepComputations {
         // the price at the beginning of the step
-        uint160 sqrtPriceStart;
+        FixedPoint96.uq64x96 sqrtPriceStart;
         // the next tick to swap to from the current tick in the swap direction
         int24 tickNext;
         // whether tickNext is initialized or not
         bool initialized;
         // sqrt(price) for the next tick (1/0)
-        uint160 sqrtPriceNext;
+        FixedPoint96.uq64x96 sqrtPriceNext;
         // how much is being swapped in in this step
         uint256 amountIn;
         // how much is being swapped out
@@ -470,7 +483,7 @@ contract UniswapV3Pair is IUniswapV3Pair {
     }
 
     function _swap(SwapParams memory params) private {
-        bool zeroForOne = params.sqrtPriceLimit < params.slot0Start.sqrtPriceCurrent;
+        bool zeroForOne = params.sqrtPriceLimit._x < params.slot0Start.sqrtPriceCurrent._x;
         bool exactInput = params.amountSpecified > 0;
 
         slot0.unlockedAndPriceBit = params.slot0Start.unlockedAndPriceBit ^ UNLOCKED_BIT;
@@ -483,11 +496,11 @@ contract UniswapV3Pair is IUniswapV3Pair {
                 priceBit: params.slot0Start.unlockedAndPriceBit & PRICE_BIT == PRICE_BIT,
                 tick: params.tickStart,
                 feeGrowthGlobal: zeroForOne ? feeGrowthGlobal0 : feeGrowthGlobal1,
-                liquidity: params.liquidityStart
+                liquidity: params.slot1Start.liquidityCurrent
             });
 
         // continue swapping as long as we haven't used the entire input/output and haven't reached the price limit
-        while (state.amountSpecifiedRemaining != 0 && state.sqrtPrice != params.sqrtPriceLimit) {
+        while (state.amountSpecifiedRemaining != 0 && state.sqrtPrice._x != params.sqrtPriceLimit._x) {
             StepComputations memory step;
 
             step.sqrtPriceStart = state.sqrtPrice;
@@ -503,7 +516,11 @@ contract UniswapV3Pair is IUniswapV3Pair {
 
             (state.sqrtPrice, step.amountIn, step.amountOut, step.feeAmount) = SwapMath.computeSwapStep(
                 state.sqrtPrice,
-                (zeroForOne ? step.sqrtPriceNext < params.sqrtPriceLimit : step.sqrtPriceNext > params.sqrtPriceLimit)
+                (
+                    zeroForOne
+                        ? step.sqrtPriceNext._x < params.sqrtPriceLimit._x
+                        : step.sqrtPriceNext._x > params.sqrtPriceLimit._x
+                )
                     ? params.sqrtPriceLimit
                     : step.sqrtPriceNext,
                 state.liquidity,
@@ -520,10 +537,10 @@ contract UniswapV3Pair is IUniswapV3Pair {
             }
 
             // update global fee tracker
-            state.feeGrowthGlobal += FixedPoint128.fraction(step.feeAmount, state.liquidity);
+            state.feeGrowthGlobal._x += FixedPoint128.fraction(step.feeAmount, state.liquidity)._x;
 
             // shift tick if we reached the next price target
-            if (state.sqrtPrice == step.sqrtPriceNext) {
+            if (state.sqrtPrice._x == step.sqrtPriceNext._x) {
                 // if the tick is initialized, run the tick transition
                 if (step.initialized) {
                     // it's ok to put this condition here, because the min/max ticks are always initialized
@@ -532,12 +549,12 @@ contract UniswapV3Pair is IUniswapV3Pair {
 
                     Tick.Info storage tickInfo = tickInfos[step.tickNext];
                     // update tick info
-                    tickInfo.feeGrowthOutside0 =
-                        (zeroForOne ? state.feeGrowthGlobal : feeGrowthGlobal0) -
-                        tickInfo.feeGrowthOutside0;
-                    tickInfo.feeGrowthOutside1 =
-                        (zeroForOne ? feeGrowthGlobal1 : state.feeGrowthGlobal) -
-                        tickInfo.feeGrowthOutside1;
+                    tickInfo.feeGrowthOutside0 = FixedPoint128.uq128x128(
+                        (zeroForOne ? state.feeGrowthGlobal._x : feeGrowthGlobal0._x) - tickInfo.feeGrowthOutside0._x
+                    );
+                    tickInfo.feeGrowthOutside1 = FixedPoint128.uq128x128(
+                        (zeroForOne ? feeGrowthGlobal1._x : state.feeGrowthGlobal._x) - tickInfo.feeGrowthOutside1._x
+                    );
                     tickInfo.secondsOutside = params.blockTimestamp - tickInfo.secondsOutside; // overflow is desired
 
                     // update liquidityCurrent, subi from right to left, addi from left to right
@@ -548,13 +565,13 @@ contract UniswapV3Pair is IUniswapV3Pair {
                 state.priceBit = zeroForOne;
                 state.tick = zeroForOne ? step.tickNext - 1 : step.tickNext;
             } else {
-                state.priceBit = state.priceBit && zeroForOne && state.sqrtPrice == step.sqrtPriceStart;
+                state.priceBit = state.priceBit && zeroForOne && state.sqrtPrice._x == step.sqrtPriceStart._x;
                 state.tick = SqrtTickMath.getTickAtSqrtRatio(state.sqrtPrice) + (state.priceBit ? int24(-1) : int24(0));
             }
         }
 
         // update liquidity if it changed
-        if (params.liquidityStart != state.liquidity) liquidityCurrent = state.liquidity;
+        if (params.slot1Start.liquidityCurrent != state.liquidity) slot1.liquidityCurrent = state.liquidity;
 
         // the price moved at least one tick, update the accumulator
         if (state.tick != params.tickStart) {
@@ -610,18 +627,18 @@ contract UniswapV3Pair is IUniswapV3Pair {
         Slot0 memory _slot0 = slot0;
         require(_slot0.unlockedAndPriceBit & UNLOCKED_BIT == UNLOCKED_BIT, 'LOK');
         require(
-            zeroForOne ? sqrtPriceLimit < _slot0.sqrtPriceCurrent : sqrtPriceLimit > _slot0.sqrtPriceCurrent,
+            zeroForOne ? sqrtPriceLimit < _slot0.sqrtPriceCurrent._x : sqrtPriceLimit > _slot0.sqrtPriceCurrent._x,
             'SPL'
         );
 
         _swap(
             SwapParams({
                 amountSpecified: amountSpecified,
-                sqrtPriceLimit: sqrtPriceLimit,
+                sqrtPriceLimit: FixedPoint96.uq64x96(sqrtPriceLimit),
                 recipient: recipient,
                 data: data,
                 slot0Start: _slot0,
-                liquidityStart: liquidityCurrent,
+                slot1Start: slot1,
                 tickStart: _tickCurrent(_slot0),
                 blockTimestamp: _blockTimestamp()
             })
