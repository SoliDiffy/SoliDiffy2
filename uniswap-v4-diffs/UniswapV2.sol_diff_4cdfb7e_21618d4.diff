diff --git a/contracts/UniswapV2.sol b/contracts/UniswapV2.sol
index a5900577..ff52710f 100644
--- a/contracts/UniswapV2.sol
+++ b/contracts/UniswapV2.sol
@@ -73,12 +73,11 @@ contract UniswapV2 is IUniswapV2, ERC20("Uniswap V2", "UNI-V2", 18, 0) {
     function _mintFee(uint balance0, uint balance1) private {
         address feeTo = IUniswapV2Factory(factory).feeTo();
         if (feeTo != address(0)) {
-            uint _invariantLast = invariantLast; // for gas savings
-            if (_invariantLast != 0) {
+            if (invariantLast != 0) {
                 uint invariant = Math.sqrt(uint(reserve0) * reserve1); // * doesn't overflow
-                if (invariant > _invariantLast) {
-                    uint numerator = totalSupply.mul(invariant.sub(_invariantLast));
-                    uint denominator = uint(4).mul(invariant).add(_invariantLast);
+                if (invariant > invariantLast) {
+                    uint numerator = totalSupply.mul(invariant.sub(invariantLast));
+                    uint denominator = uint(4).mul(invariant).add(invariantLast);
                     uint liquidity = numerator / denominator;
                     if (liquidity > 0) _mint(feeTo, liquidity);
                 }
@@ -88,18 +87,17 @@ contract UniswapV2 is IUniswapV2, ERC20("Uniswap V2", "UNI-V2", 18, 0) {
     }
 
     function mint(address to) external lock returns (uint liquidity) {
-        uint112 _reserve0 = reserve0;    // for gas savings
-        uint112 _reserve1 = reserve1;    // for gas savings
-        uint _totalSupply = totalSupply; // for gas savings
+        uint112 _reserve0 = reserve0; // for gas savings
+        uint112 _reserve1 = reserve1; // for gas savings
         uint balance0 = IERC20(token0).balanceOf(address(this));
         uint balance1 = IERC20(token1).balanceOf(address(this));
         uint amount0 = balance0.sub(_reserve0);
         uint amount1 = balance1.sub(_reserve1);
 
         _mintFee(balance0, balance1);
-        liquidity = _totalSupply == 0 ?
+        liquidity = totalSupply == 0 ?
             Math.sqrt(amount0.mul(amount1)) :
-            Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);
+            Math.min(amount0.mul(totalSupply) / _reserve0, amount1.mul(totalSupply) / _reserve1);
         require(liquidity > 0, "UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED");
         _mint(to, liquidity);
 
@@ -108,22 +106,19 @@ contract UniswapV2 is IUniswapV2, ERC20("Uniswap V2", "UNI-V2", 18, 0) {
     }
 
     function burn(address to) external lock returns (uint amount0, uint amount1) {
-        address _token0 = token0;        // for gas savings
-        address _token1 = token1;        // for gas savings
-        uint _totalSupply = totalSupply; // for gas savings
-        uint balance0 = IERC20(_token0).balanceOf(address(this));
-        uint balance1 = IERC20(_token1).balanceOf(address(this));
+        uint balance0 = IERC20(token0).balanceOf(address(this));
+        uint balance1 = IERC20(token1).balanceOf(address(this));
         uint liquidity = balanceOf[address(this)];
 
         _mintFee(balance0, balance1);
         // use balances instead of reserves to address edges cases
-        amount0 = liquidity.mul(balance0) / _totalSupply;
-        amount1 = liquidity.mul(balance1) / _totalSupply;
+        amount0 = liquidity.mul(balance0) / totalSupply;
+        amount1 = liquidity.mul(balance1) / totalSupply;
         require(amount0 > 0 && amount1 > 0, "UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED");
-        _safeTransfer(_token0, to, amount0);
-        _safeTransfer(_token1, to, amount1);
-        balance0 = IERC20(_token0).balanceOf(address(this));
-        balance1 = IERC20(_token1).balanceOf(address(this));
+        _safeTransfer(token0, to, amount0);
+        _safeTransfer(token1, to, amount1);
+        balance0 = IERC20(token0).balanceOf(address(this));
+        balance1 = IERC20(token1).balanceOf(address(this));
         _burn(address(this), liquidity);
 
         _update(balance0, balance1, reserve0, reserve1);
@@ -133,27 +128,25 @@ contract UniswapV2 is IUniswapV2, ERC20("Uniswap V2", "UNI-V2", 18, 0) {
     function swap(address tokenIn, uint amountOut, address to) external lock {
         uint112 _reserve0 = reserve0; // for gas savings
         uint112 _reserve1 = reserve1; // for gas savings
-        address _token0 = token0;     // for gas savings
-        address _token1 = token1;     // for gas savings
         uint balance0; uint balance1; uint amountIn;
 
-        if (tokenIn == _token0) {
+        if (tokenIn == token0) {
             require(0 < amountOut && amountOut < _reserve1, "UniswapV2: INVALID_OUTPUT_AMOUNT");
-            balance0 = IERC20(_token0).balanceOf(address(this));
+            balance0 = IERC20(token0).balanceOf(address(this));
             amountIn = balance0.sub(_reserve0);
             require(amountIn > 0, "UniswapV2: INSUFFICIENT_INPUT_AMOUNT");
             require(amountIn.mul(_reserve1 - amountOut).mul(997) >= amountOut.mul(_reserve0).mul(1000), "UniswapV2: K");
-            _safeTransfer(_token1, to, amountOut);
-            balance1 = IERC20(_token1).balanceOf(address(this));
+            _safeTransfer(token1, to, amountOut);
+            balance1 = IERC20(token1).balanceOf(address(this));
         } else {
-            require(tokenIn == _token1, "UniswapV2: INVALID_INPUT_TOKEN");
+            require(tokenIn == token1, "UniswapV2: INVALID_INPUT_TOKEN");
             require(0 < amountOut && amountOut < _reserve0, "UniswapV2: INVALID_OUTPUT_AMOUNT");
-            balance1 = IERC20(_token1).balanceOf(address(this));
+            balance1 = IERC20(token1).balanceOf(address(this));
             amountIn = balance1.sub(_reserve1);
             require(amountIn > 0, "UniswapV2: INSUFFICIENT_INPUT_AMOUNT");
             require(amountIn.mul(_reserve0 - amountOut).mul(997) >= amountOut.mul(_reserve1).mul(1000), "UniswapV2: K");
-            _safeTransfer(_token0, to, amountOut);
-            balance0 = IERC20(_token0).balanceOf(address(this));
+            _safeTransfer(token0, to, amountOut);
+            balance0 = IERC20(token0).balanceOf(address(this));
         }
 
         _update(balance0, balance1, _reserve0, _reserve1);
@@ -162,10 +155,8 @@ contract UniswapV2 is IUniswapV2, ERC20("Uniswap V2", "UNI-V2", 18, 0) {
 
     // force balances to match reserves
     function skim(address to) external lock {
-        address _token0 = token0; // for gas savings
-        address _token1 = token1; // for gas savings
-        _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0));
-        _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1));
+        _safeTransfer(token0, to, IERC20(token0).balanceOf(address(this)).sub(reserve0));
+        _safeTransfer(token1, to, IERC20(token1).balanceOf(address(this)).sub(reserve1));
     }
 
     // force reserves to match balances
