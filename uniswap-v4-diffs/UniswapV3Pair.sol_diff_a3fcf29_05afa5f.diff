diff --git a/contracts/UniswapV3Pair.sol b/contracts/UniswapV3Pair.sol
index 2cc696ca..0242e785 100644
--- a/contracts/UniswapV3Pair.sol
+++ b/contracts/UniswapV3Pair.sol
@@ -7,6 +7,7 @@ import '@uniswap/lib/contracts/libraries/Babylonian.sol';
 import '@uniswap/lib/contracts/libraries/TransferHelper.sol';
 
 import './libraries/SafeMath.sol';
+import './libraries/FixedPointExtra.sol';
 import './libraries/TickMath.sol';
 import './libraries/PriceMath.sol';
 
@@ -161,7 +162,7 @@ contract UniswapV3Pair is IUniswapV3Pair {
         assert(growthBelow._x != 0);
         // tick is above the current tick, meaning growth outside represents growth above, not below, so adjust
         if (tick > tickCurrent) {
-            growthBelow = g.divuq(growthBelow);
+            growthBelow = FixedPointExtra.divuq(g, growthBelow);
         }
     }
 
@@ -174,7 +175,7 @@ contract UniswapV3Pair is IUniswapV3Pair {
         assert(growthAbove._x != 0);
         // tick is at or below the current tick, meaning growth outside represents growth below, not above, so adjust
         if (tick <= tickCurrent) {
-            growthAbove = g.divuq(growthAbove);
+            growthAbove = FixedPointExtra.divuq(g, growthAbove);
         }
     }
 
@@ -187,7 +188,7 @@ contract UniswapV3Pair is IUniswapV3Pair {
         FixedPoint.uq112x112 memory g = getG();
         FixedPoint.uq112x112 memory growthBelow = _getGrowthBelow(tickLower, tickInfoLower, g);
         FixedPoint.uq112x112 memory growthAbove = _getGrowthAbove(tickUpper, tickInfoUpper, g);
-        growthInside = g.divuq(growthBelow.muluq(growthAbove));
+        growthInside = FixedPointExtra.divuq(g, FixedPointExtra.muluq(growthBelow, growthAbove));
     }
 
     // given a price and a liquidity amount, return the value of that liquidity at the price
@@ -198,8 +199,8 @@ contract UniswapV3Pair is IUniswapV3Pair {
         pure
         returns (int112 amount0, int112 amount1)
     {
-        amount0 = price.reciprocal().sqrt().muli(liquidity).itoInt112();
-        amount1 = price.muli(amount0).itoInt112();
+        amount0 = FixedPointExtra.muli(price.reciprocal().sqrt(), liquidity).itoInt112();
+        amount1 = FixedPointExtra.muli(price, amount0).itoInt112();
     }
 
     constructor(
@@ -608,7 +609,7 @@ contract UniswapV3Pair is IUniswapV3Pair {
                     // TODO this should always move the price _down_ (if it has to move at all), because that's the
                     // direction we're moving...floor division should ensure that this is the case with positive deltas,
                     // but not with negative
-                    int112 token1VirtualDelta = step.nextPrice.muli(token0VirtualDelta).itoInt112();
+                    int112 token1VirtualDelta = FixedPointExtra.muli(step.nextPrice, token0VirtualDelta).itoInt112();
                     // TODO i think we could squeeze out a tiny bit more precision under certain circumstances by doing:
                     // a) summing total negative and positive token0VirtualDeltas
                     // b) calculating the total negative and positive virtualSupply delta
@@ -636,7 +637,7 @@ contract UniswapV3Pair is IUniswapV3Pair {
 
                     // update tick info
                     // overflow is desired
-                    tickInfo.growthOutside = getG().divuq(tickInfo.growthOutside);
+                    tickInfo.growthOutside = FixedPointExtra.divuq(getG(), tickInfo.growthOutside);
                     tickInfo.secondsOutside = _blockTimestamp() - tickInfo.secondsOutside;
                 }
 
