diff --git a/contracts/PoolManager.sol b/contracts/PoolManager.sol
index 81dc10a0..a2237cdd 100644
--- a/contracts/PoolManager.sol
+++ b/contracts/PoolManager.sol
@@ -1,12 +1,14 @@
 // SPDX-License-Identifier: UNLICENSED
 pragma solidity ^0.8.15;
 
+import {TransferHelper} from './libraries/TransferHelper.sol';
 import {Hooks} from './libraries/Hooks.sol';
 import {Pool} from './libraries/Pool.sol';
 import {SafeCast} from './libraries/SafeCast.sol';
 import {Position} from './libraries/Position.sol';
-import {Currency, CurrencyLibrary} from './libraries/CurrencyLibrary.sol';
+import {TransferHelper} from './libraries/TransferHelper.sol';
 
+import {IERC20Minimal} from './interfaces/external/IERC20Minimal.sol';
 import {NoDelegateCall} from './NoDelegateCall.sol';
 import {Owned} from './Owned.sol';
 import {IHooks} from './interfaces/IHooks.sol';
@@ -25,7 +27,7 @@ contract PoolManager is IPoolManager, Owned, NoDelegateCall, ERC1155, IERC1155Re
     using Pool for *;
     using Hooks for IHooks;
     using Position for mapping(bytes32 => Position.Info);
-    using CurrencyLibrary for Currency;
+    using TransferHelper for IERC20Minimal;
 
     /// @inheritdoc IPoolManager
     int24 public constant override MAX_TICK_SPACING = type(int16).max;
@@ -35,7 +37,7 @@ contract PoolManager is IPoolManager, Owned, NoDelegateCall, ERC1155, IERC1155Re
 
     mapping(bytes32 => Pool.State) public pools;
 
-    mapping(Currency => uint256) public override protocolFeesAccrued;
+    mapping(IERC20Minimal => uint256) public override protocolFeesAccrued;
     IProtocolFeeController public protocolFeeController;
 
     uint256 private immutable controllerGasLimit;
@@ -101,11 +103,11 @@ contract PoolManager is IPoolManager, Owned, NoDelegateCall, ERC1155, IERC1155Re
             }
         }
 
-        emit Initialize(id, key.currency0, key.currency1, key.fee, key.tickSpacing, key.hooks);
+        emit Initialize(id, key.token0, key.token1, key.fee, key.tickSpacing, key.hooks);
     }
 
     /// @inheritdoc IPoolManager
-    mapping(Currency => uint256) public override reservesOf;
+    mapping(IERC20Minimal => uint256) public override reservesOf;
 
     /// @inheritdoc IPoolManager
     address[] public override lockedBy;
@@ -115,37 +117,37 @@ contract PoolManager is IPoolManager, Owned, NoDelegateCall, ERC1155, IERC1155Re
         return lockedBy.length;
     }
 
-    /// @member index The index in the currenciesTouched array where the currency is found
-    /// @member delta The delta that is owed for that particular currency
+    /// @member index The index in the tokensTouched array where the token is found
+    /// @member delta The delta that is owed for that particular token
     struct IndexAndDelta {
         uint8 index;
         int248 delta;
     }
 
-    /// @member currenciesTouched The currencies that have been touched by this locker
-    /// @member currencyDelta The amount owed to the locker (positive) or owed to the pool (negative) of the currency
+    /// @member tokensTouched The tokens that have been touched by this locker
+    /// @member tokenDelta The amount owed to the locker (positive) or owed to the pool (negative) of the token
     struct LockState {
-        Currency[] currenciesTouched;
-        mapping(Currency => IndexAndDelta) currencyDelta;
+        IERC20Minimal[] tokensTouched;
+        mapping(IERC20Minimal => IndexAndDelta) tokenDelta;
     }
 
-    /// @dev Represents the state of the locker at the given index. Each locker must have net 0 currencies owed before
+    /// @dev Represents the state of the locker at the given index. Each locker must have net 0 tokens owed before
     /// releasing their lock. Note this is private because the nested mappings cannot be exposed as a public variable.
     mapping(uint256 => LockState) private lockStates;
 
     /// @inheritdoc IPoolManager
-    function getCurrenciesTouchedLength(uint256 id) external view returns (uint256) {
-        return lockStates[id].currenciesTouched.length;
+    function getTokensTouchedLength(uint256 id) external view returns (uint256) {
+        return lockStates[id].tokensTouched.length;
     }
 
     /// @inheritdoc IPoolManager
-    function getCurrenciesTouched(uint256 id, uint256 index) external view returns (Currency) {
-        return lockStates[id].currenciesTouched[index];
+    function getTokensTouched(uint256 id, uint256 index) external view returns (IERC20Minimal) {
+        return lockStates[id].tokensTouched[index];
     }
 
     /// @inheritdoc IPoolManager
-    function getCurrencyDelta(uint256 id, Currency currency) external view returns (uint8 index, int248 delta) {
-        IndexAndDelta storage indexAndDelta = lockStates[id].currencyDelta[currency];
+    function getTokenDelta(uint256 id, IERC20Minimal token) external view returns (uint8 index, int248 delta) {
+        IndexAndDelta storage indexAndDelta = lockStates[id].tokenDelta[token];
         (index, delta) = (indexAndDelta.index, indexAndDelta.delta);
     }
 
@@ -159,49 +161,49 @@ contract PoolManager is IPoolManager, Owned, NoDelegateCall, ERC1155, IERC1155Re
 
         unchecked {
             LockState storage lockState = lockStates[id];
-            uint256 numCurrenciesTouched = lockState.currenciesTouched.length;
-            for (uint256 i; i < numCurrenciesTouched; i++) {
-                Currency currency = lockState.currenciesTouched[i];
-                IndexAndDelta storage indexAndDelta = lockState.currencyDelta[currency];
-                if (indexAndDelta.delta != 0) revert CurrencyNotSettled(currency, indexAndDelta.delta);
-                delete lockState.currencyDelta[currency];
+            uint256 numTokensTouched = lockState.tokensTouched.length;
+            for (uint256 i; i < numTokensTouched; i++) {
+                IERC20Minimal token = lockState.tokensTouched[i];
+                IndexAndDelta storage indexAndDelta = lockState.tokenDelta[token];
+                if (indexAndDelta.delta != 0) revert TokenNotSettled(token, indexAndDelta.delta);
+                delete lockState.tokenDelta[token];
             }
-            delete lockState.currenciesTouched;
+            delete lockState.tokensTouched;
         }
 
         lockedBy.pop();
     }
 
-    /// @dev Adds a currency to a unique list of currencies that have been touched
-    function _addCurrencyToSet(Currency currency) internal returns (uint8 index) {
+    /// @dev Adds a token to a unique list of tokens that have been touched
+    function _addTokenToSet(IERC20Minimal token) internal returns (uint8 index) {
         LockState storage lockState = lockStates[lockedBy.length - 1];
-        uint256 numCurrenciesTouched = lockState.currenciesTouched.length;
-        if (numCurrenciesTouched == 0) {
-            lockState.currenciesTouched.push(currency);
+        uint256 numTokensTouched = lockState.tokensTouched.length;
+        if (numTokensTouched == 0) {
+            lockState.tokensTouched.push(token);
             return 0;
         }
 
-        IndexAndDelta storage indexAndDelta = lockState.currencyDelta[currency];
+        IndexAndDelta storage indexAndDelta = lockState.tokenDelta[token];
         index = indexAndDelta.index;
 
-        if (index == 0 && !lockState.currenciesTouched[index].equals(currency)) {
-            if (numCurrenciesTouched >= type(uint8).max) revert MaxCurrenciesTouched();
-            index = uint8(numCurrenciesTouched);
+        if (index == 0 && lockState.tokensTouched[index] != token) {
+            if (numTokensTouched >= type(uint8).max) revert MaxTokensTouched();
+            index = uint8(numTokensTouched);
             indexAndDelta.index = index;
-            lockState.currenciesTouched.push(currency);
+            lockState.tokensTouched.push(token);
         }
     }
 
-    function _accountDelta(Currency currency, int256 delta) internal {
+    function _accountDelta(IERC20Minimal token, int256 delta) internal {
         if (delta == 0) return;
-        _addCurrencyToSet(currency);
-        lockStates[lockedBy.length - 1].currencyDelta[currency].delta += delta.toInt248();
+        _addTokenToSet(token);
+        lockStates[lockedBy.length - 1].tokenDelta[token].delta += delta.toInt248();
     }
 
-    /// @dev Accumulates a balance change to a map of currency to balance changes
+    /// @dev Accumulates a balance change to a map of token to balance changes
     function _accountPoolBalanceDelta(PoolKey memory key, IPoolManager.BalanceDelta memory delta) internal {
-        _accountDelta(key.currency0, delta.amount0);
-        _accountDelta(key.currency1, delta.amount1);
+        _accountDelta(key.token0, delta.amount0);
+        _accountDelta(key.token1, delta.amount1);
     }
 
     modifier onlyByLocker() {
@@ -274,11 +276,10 @@ contract PoolManager is IPoolManager, Owned, NoDelegateCall, ERC1155, IERC1155Re
         );
 
         _accountPoolBalanceDelta(key, delta);
-        // the fee is on the input currency
+        // the fee is on the input token
 
         unchecked {
-            if (feeForProtocol > 0)
-                protocolFeesAccrued[params.zeroForOne ? key.currency0 : key.currency1] += feeForProtocol;
+            if (feeForProtocol > 0) protocolFeesAccrued[params.zeroForOne ? key.token0 : key.token1] += feeForProtocol;
         }
 
         if (key.hooks.shouldCallAfterSwap()) {
@@ -315,37 +316,37 @@ contract PoolManager is IPoolManager, Owned, NoDelegateCall, ERC1155, IERC1155Re
 
     /// @inheritdoc IPoolManager
     function take(
-        Currency currency,
+        IERC20Minimal token,
         address to,
         uint256 amount
     ) external override noDelegateCall onlyByLocker {
-        _accountDelta(currency, amount.toInt256());
-        reservesOf[currency] -= amount;
-        currency.transfer(to, amount);
+        _accountDelta(token, amount.toInt256());
+        reservesOf[token] -= amount;
+        token.safeTransfer(to, amount);
     }
 
     /// @inheritdoc IPoolManager
     function mint(
-        Currency currency,
+        IERC20Minimal token,
         address to,
         uint256 amount
     ) external override noDelegateCall onlyByLocker {
-        _accountDelta(currency, amount.toInt256());
-        _mint(to, currency.toId(), amount, '');
+        _accountDelta(token, amount.toInt256());
+        _mint(to, uint256(uint160(address(token))), amount, '');
     }
 
     /// @inheritdoc IPoolManager
-    function settle(Currency currency) external payable override noDelegateCall onlyByLocker returns (uint256 paid) {
-        uint256 reservesBefore = reservesOf[currency];
-        reservesOf[currency] = currency.balanceOfSelf();
-        paid = reservesOf[currency] - reservesBefore;
+    function settle(IERC20Minimal token) external override noDelegateCall onlyByLocker returns (uint256 paid) {
+        uint256 reservesBefore = reservesOf[token];
+        reservesOf[token] = token.balanceOf(address(this));
+        paid = reservesOf[token] - reservesBefore;
         // subtraction must be safe
-        _accountDelta(currency, -(paid.toInt256()));
+        _accountDelta(token, -(paid.toInt256()));
     }
 
-    function _burnAndAccount(Currency currency, uint256 amount) internal {
-        _burn(address(this), currency.toId(), amount);
-        _accountDelta(currency, -(amount.toInt256()));
+    function _burnAndAccount(IERC20Minimal token, uint256 amount) internal {
+        _burn(address(this), uint256(uint160(address((token)))), amount);
+        _accountDelta(IERC20Minimal(token), -(amount.toInt256()));
     }
 
     function onERC1155Received(
@@ -356,7 +357,7 @@ contract PoolManager is IPoolManager, Owned, NoDelegateCall, ERC1155, IERC1155Re
         bytes calldata
     ) external returns (bytes4) {
         if (msg.sender != address(this)) revert NotPoolManagerToken();
-        _burnAndAccount(CurrencyLibrary.fromId(id), value);
+        _burnAndAccount(IERC20Minimal(address(uint160(id))), value);
         return IERC1155Receiver.onERC1155Received.selector;
     }
 
@@ -371,7 +372,7 @@ contract PoolManager is IPoolManager, Owned, NoDelegateCall, ERC1155, IERC1155Re
         // unchecked to save gas on incrementations of i
         unchecked {
             for (uint256 i; i < ids.length; i++) {
-                _burnAndAccount(CurrencyLibrary.fromId(ids[i]), values[i]);
+                _burnAndAccount(IERC20Minimal(address(uint160(ids[i]))), values[i]);
             }
         }
         return IERC1155Receiver.onERC1155BatchReceived.selector;
@@ -405,18 +406,15 @@ contract PoolManager is IPoolManager, Owned, NoDelegateCall, ERC1155, IERC1155Re
 
     function collectProtocolFees(
         address recipient,
-        Currency currency,
+        IERC20Minimal token,
         uint256 amount
     ) external returns (uint256) {
         if (msg.sender != owner && msg.sender != address(protocolFeeController)) revert InvalidCaller();
 
-        amount = (amount == 0) ? protocolFeesAccrued[currency] : amount;
-        protocolFeesAccrued[currency] -= amount;
-        currency.transfer(recipient, amount);
+        amount = (amount == 0) ? protocolFeesAccrued[token] : amount;
+        protocolFeesAccrued[token] -= amount;
+        TransferHelper.safeTransfer(token, recipient, amount);
 
         return amount;
     }
-
-    /// @notice receive native tokens for native pools
-    receive() external payable {}
 }
