diff --git a/contracts/libraries/Oracle.sol b/contracts/libraries/Oracle.sol
index 822f356f..fbd0db5e 100644
--- a/contracts/libraries/Oracle.sol
+++ b/contracts/libraries/Oracle.sol
@@ -35,20 +35,22 @@ library Oracle {
     /// @param tick The active tick at the time of the new observation
     /// @param liquidity The total in-range liquidity at the time of the new observation
     /// @return Observation The newly populated observation
-    function transform(Observation memory last, uint32 blockTimestamp, int24 tick, uint128 liquidity)
-        private
-        pure
-        returns (Observation memory)
-    {
+    function transform(
+        Observation memory last,
+        uint32 blockTimestamp,
+        int24 tick,
+        uint128 liquidity
+    ) private pure returns (Observation memory) {
         unchecked {
             uint32 delta = blockTimestamp - last.blockTimestamp;
-            return Observation({
-                blockTimestamp: blockTimestamp,
-                tickCumulative: last.tickCumulative + int56(tick) * int56(uint56(delta)),
-                secondsPerLiquidityCumulativeX128: last.secondsPerLiquidityCumulativeX128
-                    + ((uint160(delta) << 128) / (liquidity > 0 ? liquidity : 1)),
-                initialized: true
-            });
+            return
+                Observation({
+                    blockTimestamp: blockTimestamp,
+                    tickCumulative: last.tickCumulative + int56(tick) * int56(uint56(delta)),
+                    secondsPerLiquidityCumulativeX128: last.secondsPerLiquidityCumulativeX128 +
+                        ((uint160(delta) << 128) / (liquidity > 0 ? liquidity : 1)),
+                    initialized: true
+                });
         }
     }
 
@@ -57,10 +59,10 @@ library Oracle {
     /// @param time The time of the oracle initialization, via block.timestamp truncated to uint32
     /// @return cardinality The number of populated elements in the oracle array
     /// @return cardinalityNext The new length of the oracle array, independent of population
-    function initialize(Observation[65535] storage self, uint32 time)
-        internal
-        returns (uint16 cardinality, uint16 cardinalityNext)
-    {
+    function initialize(
+        Observation[65535] storage self,
+        uint32 time
+    ) internal returns (uint16 cardinality, uint16 cardinalityNext) {
         self[0] = Observation({
             blockTimestamp: time,
             tickCumulative: 0,
@@ -122,9 +124,7 @@ library Oracle {
             if (next <= current) return current;
             // store in each slot to prevent fresh SSTOREs in swaps
             // this data will not be used because the initialized boolean is still false
-            for (uint16 i = current; i < next; i++) {
-                self[i].blockTimestamp = 1;
-            }
+            for (uint16 i = current; i < next; i++) self[i].blockTimestamp = 1;
             return next;
         }
     }
@@ -158,11 +158,13 @@ library Oracle {
     /// @param cardinality The number of populated elements in the oracle array
     /// @return beforeOrAt The observation recorded before, or at, the target
     /// @return atOrAfter The observation recorded at, or after, the target
-    function binarySearch(Observation[65535] storage self, uint32 time, uint32 target, uint16 index, uint16 cardinality)
-        private
-        view
-        returns (Observation memory beforeOrAt, Observation memory atOrAfter)
-    {
+    function binarySearch(
+        Observation[65535] storage self,
+        uint32 time,
+        uint32 target,
+        uint16 index,
+        uint16 cardinality
+    ) private view returns (Observation memory beforeOrAt, Observation memory atOrAfter) {
         unchecked {
             uint256 l = (index + 1) % cardinality; // oldest observation
             uint256 r = l + cardinality - 1; // newest observation
@@ -232,9 +234,8 @@ library Oracle {
             if (!beforeOrAt.initialized) beforeOrAt = self[0];
 
             // ensure that the target is chronologically at or after the oldest observation
-            if (!lte(time, beforeOrAt.blockTimestamp, target)) {
+            if (!lte(time, beforeOrAt.blockTimestamp, target))
                 revert TargetPredatesOldestObservation(beforeOrAt.blockTimestamp, target);
-            }
 
             // if we've reached this point, we have to binary search
             return binarySearch(self, time, target, index, cardinality);
@@ -272,8 +273,15 @@ library Oracle {
 
             uint32 target = time - secondsAgo;
 
-            (Observation memory beforeOrAt, Observation memory atOrAfter) =
-                getSurroundingObservations(self, time, target, tick, index, liquidity, cardinality);
+            (Observation memory beforeOrAt, Observation memory atOrAfter) = getSurroundingObservations(
+                self,
+                time,
+                target,
+                tick,
+                index,
+                liquidity,
+                cardinality
+            );
 
             if (target == beforeOrAt.blockTimestamp) {
                 // we're at the left boundary
@@ -286,17 +294,15 @@ library Oracle {
                 uint32 observationTimeDelta = atOrAfter.blockTimestamp - beforeOrAt.blockTimestamp;
                 uint32 targetDelta = target - beforeOrAt.blockTimestamp;
                 return (
-                    beforeOrAt.tickCumulative
-                        + ((atOrAfter.tickCumulative - beforeOrAt.tickCumulative) / int56(uint56(observationTimeDelta)))
-                            * int56(uint56(targetDelta)),
-                    beforeOrAt.secondsPerLiquidityCumulativeX128
-                        + uint160(
-                            (
-                                uint256(
-                                    atOrAfter.secondsPerLiquidityCumulativeX128
-                                        - beforeOrAt.secondsPerLiquidityCumulativeX128
-                                ) * targetDelta
-                            ) / observationTimeDelta
+                    beforeOrAt.tickCumulative +
+                        ((atOrAfter.tickCumulative - beforeOrAt.tickCumulative) / int56(uint56(observationTimeDelta))) *
+                        int56(uint56(targetDelta)),
+                    beforeOrAt.secondsPerLiquidityCumulativeX128 +
+                        uint160(
+                            (uint256(
+                                atOrAfter.secondsPerLiquidityCumulativeX128 -
+                                    beforeOrAt.secondsPerLiquidityCumulativeX128
+                            ) * targetDelta) / observationTimeDelta
                         )
                 );
             }
@@ -329,8 +335,15 @@ library Oracle {
             tickCumulatives = new int56[](secondsAgos.length);
             secondsPerLiquidityCumulativeX128s = new uint160[](secondsAgos.length);
             for (uint256 i = 0; i < secondsAgos.length; i++) {
-                (tickCumulatives[i], secondsPerLiquidityCumulativeX128s[i]) =
-                    observeSingle(self, time, secondsAgos[i], tick, index, liquidity, cardinality);
+                (tickCumulatives[i], secondsPerLiquidityCumulativeX128s[i]) = observeSingle(
+                    self,
+                    time,
+                    secondsAgos[i],
+                    tick,
+                    index,
+                    liquidity,
+                    cardinality
+                );
             }
         }
     }
