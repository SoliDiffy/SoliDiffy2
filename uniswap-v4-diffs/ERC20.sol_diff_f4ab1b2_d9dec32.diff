diff --git a/contracts/token/ERC20.sol b/contracts/token/ERC20.sol
index d0d77271..7079b815 100644
--- a/contracts/token/ERC20.sol
+++ b/contracts/token/ERC20.sol
@@ -1,6 +1,7 @@
 pragma solidity 0.5.13;
 
 import "../interfaces/IERC20.sol";
+
 import "../libraries/SafeMath.sol";
 
 contract ERC20 is IERC20 {
@@ -15,7 +16,7 @@ contract ERC20 is IERC20 {
 
 	bytes32 public DOMAIN_SEPARATOR;
     // keccak256("Approve(address owner,address spender,uint256 value,uint256 nonce,uint256 expiration)");
-	bytes32 public constant APPROVE_TYPEHASH = hex"25a0822e8c2ed7ff64a57c55df37ff176282195b9e0c9bb770ed24a300c89762";
+	bytes32 public constant APPROVE_TYPEHASH = hex'25a0822e8c2ed7ff64a57c55df37ff176282195b9e0c9bb770ed24a300c89762';
     mapping (address => uint) public nonces;
 
     event Transfer(address indexed from, address indexed to, uint value);
@@ -29,9 +30,7 @@ contract ERC20 is IERC20 {
         name = _name;
         symbol = _symbol;
         decimals = _decimals;
-        if (_totalSupply > 0) {
-            mint(msg.sender, _totalSupply);
-        }
+        if (_totalSupply > 0) mint(msg.sender, _totalSupply);
         DOMAIN_SEPARATOR = keccak256(abi.encode(
 			keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
 			keccak256(bytes(name)),
@@ -85,18 +84,27 @@ contract ERC20 is IERC20 {
     {
         require(nonce == nonces[owner]++, "ERC20: INVALID_NONCE");
         // solium-disable-next-line security/no-block-members
-        require(expiration > block.timestamp, "ERC20: EXPIRED");
-        require(v == 27 || v == 28, "ERC20: INVALID_V");
-        require(uint(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, "ERC20: INVALID_S");
+        require(expiration > block.timestamp, "ERC20: EXPIRED_SIGNATURE");
+        require(v == 27 || v == 28, "ECDSA: INVALID_V");
+        require(uint(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, "ECDSA: INVALID_S");
+
         bytes32 digest = keccak256(abi.encodePacked(
-            hex"19",
-            hex"01",
+            hex'19',
+            hex'01',
             DOMAIN_SEPARATOR,
-            keccak256(abi.encode(APPROVE_TYPEHASH, owner, spender, value, nonce, expiration))
+            keccak256(abi.encode(
+                APPROVE_TYPEHASH, owner, spender, value, nonce, expiration
+            ))
         ));
         address recoveredAddress = ecrecover(digest, v, r, s);
-        require(recoveredAddress != address(0), "ERC20: INVALID_SIGNATURE");
-        require(recoveredAddress == owner, "ERC20: INVALID_ADDRESS");
+        if (recoveredAddress != owner) {
+            recoveredAddress = ecrecover(
+                keccak256(abi.encodePacked(hex"19", "Ethereum Signed Message:", hex"32", digest)), v, r, s
+            );
+        }
+        require(recoveredAddress != address(0), "ERC20: INVALID_RECOVERED_ADDRESS");
+        require(recoveredAddress == owner, "ERC20: INVALID_SIGNATURE");
+
         _approve(owner, spender, value);
     }
 
