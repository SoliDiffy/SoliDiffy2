diff --git a/contracts/UniswapV3Pair.sol b/contracts/UniswapV3Pair.sol
index 49de1920..6ac34c42 100644
--- a/contracts/UniswapV3Pair.sol
+++ b/contracts/UniswapV3Pair.sol
@@ -16,7 +16,6 @@ import './libraries/SqrtTickMath.sol';
 import './libraries/SpacedTickBitmap.sol';
 import './libraries/FixedPoint128.sol';
 import './libraries/Tick.sol';
-import './libraries/Position.sol';
 
 import './interfaces/IERC20.sol';
 import './interfaces/IUniswapV3Pair.sol';
@@ -36,7 +35,6 @@ contract UniswapV3Pair is IUniswapV3Pair {
     using MixedSafeMath for uint256;
     using SpacedTickBitmap for mapping(int16 => uint256);
     using Tick for mapping(int24 => Tick.Info);
-    using Position for mapping(bytes32 => Position.Info);
 
     uint8 private constant PRICE_BIT = 0x10;
     uint8 private constant UNLOCKED_BIT = 0x01;
@@ -95,8 +93,18 @@ contract UniswapV3Pair is IUniswapV3Pair {
     uint256 public override feeToFees0;
     uint256 public override feeToFees1;
 
-    mapping(int24 => Tick.Info) public ticks;
-    mapping(bytes32 => Position.Info) public positions;
+    mapping(int24 => Tick.Info) public tickInfos;
+
+    struct Position {
+        uint128 liquidity;
+        // fee growth per unit of liquidity as of the last modification
+        uint256 feeGrowthInside0LastX128;
+        uint256 feeGrowthInside1LastX128;
+        // the fees owed to the position owner in token0/token1
+        uint256 feesOwed0;
+        uint256 feesOwed1;
+    }
+    mapping(bytes32 => Position) public positions;
 
     // lock the pair for operations that do not modify the price, i.e. everything but swap
     modifier lockNoPriceMovement() {
@@ -107,6 +115,14 @@ contract UniswapV3Pair is IUniswapV3Pair {
         slot0.unlockedAndPriceBit = uapb;
     }
 
+    function _getPosition(
+        address owner,
+        int24 tickLower,
+        int24 tickUpper
+    ) private view returns (Position storage position) {
+        position = positions[keccak256(abi.encodePacked(owner, tickLower, tickUpper))];
+    }
+
     // throws if the pair is not initialized, which is implicitly used throughout to gatekeep various functions
     function tickCurrent() public view override returns (int24) {
         return _tickCurrent(slot0);
@@ -148,7 +164,7 @@ contract UniswapV3Pair is IUniswapV3Pair {
         int24 current,
         int128 liquidityDelta
     ) private returns (Tick.Info storage tickInfo) {
-        tickInfo = ticks[tick];
+        tickInfo = tickInfos[tick];
 
         if (liquidityDelta != 0) {
             if (tickInfo.liquidityGross == 0) {
@@ -173,7 +189,7 @@ contract UniswapV3Pair is IUniswapV3Pair {
     }
 
     function _clearTick(int24 tick) private {
-        delete ticks[tick];
+        delete tickInfos[tick];
         tickBitmap.flipTick(tick, tickSpacing);
     }
 
@@ -208,7 +224,7 @@ contract UniswapV3Pair is IUniswapV3Pair {
         int128 liquidityDelta,
         int24 tick
     ) private {
-        Position.Info storage position = positions.getPosition(owner, tickLower, tickUpper);
+        Position storage position = _getPosition(owner, tickLower, tickUpper);
 
         if (liquidityDelta < 0) {
             require(position.liquidity >= uint128(-liquidityDelta), 'CP');
@@ -220,7 +236,7 @@ contract UniswapV3Pair is IUniswapV3Pair {
         Tick.Info storage tickInfoUpper = _updateTick(tickUpper, tick, liquidityDelta);
 
         (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) =
-            ticks.getFeeGrowthInside(tickLower, tickUpper, tick, feeGrowthGlobal0X128, feeGrowthGlobal1X128);
+            tickInfos.getFeeGrowthInside(tickLower, tickUpper, tick, feeGrowthGlobal0X128, feeGrowthGlobal1X128);
 
         // calculate accumulated fees
         uint256 feesOwed0 =
@@ -282,7 +298,7 @@ contract UniswapV3Pair is IUniswapV3Pair {
         require(tickLower >= MIN_TICK, 'TLM');
         require(tickUpper <= MAX_TICK, 'TUM');
 
-        Position.Info storage position = positions.getPosition(msg.sender, tickLower, tickUpper);
+        Position storage position = _getPosition(msg.sender, tickLower, tickUpper);
 
         amount0 = amount0Requested > position.feesOwed0 ? position.feesOwed0 : amount0Requested;
         amount1 = amount1Requested > position.feesOwed1 ? position.feesOwed1 : amount1Requested;
@@ -545,7 +561,7 @@ contract UniswapV3Pair is IUniswapV3Pair {
                     if (zeroForOne) require(step.tickNext > MIN_TICK, 'MIN');
                     else require(step.tickNext < MAX_TICK, 'MAX');
 
-                    Tick.Info storage tickInfo = ticks[step.tickNext];
+                    Tick.Info storage tickInfo = tickInfos[step.tickNext];
                     // update tick info
                     tickInfo.feeGrowthOutside0X128 =
                         (zeroForOne ? state.feeGrowthGlobalX128 : feeGrowthGlobal0X128) -
