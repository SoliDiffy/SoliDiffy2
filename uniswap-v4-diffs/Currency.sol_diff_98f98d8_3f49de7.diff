diff --git a/src/types/Currency.sol b/src/types/Currency.sol
index 0c2656b3..4bffe0da 100644
--- a/src/types/Currency.sol
+++ b/src/types/Currency.sol
@@ -2,7 +2,6 @@
 pragma solidity ^0.8.20;
 
 import {IERC20Minimal} from "../interfaces/external/IERC20Minimal.sol";
-import {CustomRevert} from "../libraries/CustomRevert.sol";
 
 type Currency is address;
 
@@ -28,8 +27,6 @@ function greaterThanOrEqualTo(Currency currency, Currency other) pure returns (b
 /// @title CurrencyLibrary
 /// @dev This library allows for transferring and holding native tokens and ERC20 tokens
 library CurrencyLibrary {
-    using CustomRevert for bytes4;
-
     /// @notice Thrown when a native transfer fails
     error NativeTransferFailed();
 
@@ -40,44 +37,36 @@ library CurrencyLibrary {
     Currency public constant NATIVE = Currency.wrap(address(0));
 
     function transfer(Currency currency, address to, uint256 amount) internal {
-        // altered from https://github.com/transmissions11/solmate/blob/44a9963d4c78111f77caa0e65d677b8b46d6f2e6/src/utils/SafeTransferLib.sol
+        // altered from https://github.com/Vectorized/solady/blob/89101d53b7c8784cca935c1f2f6403639cee48b2/src/utils/SafeTransferLib.sol
         // modified custom error selectors
 
-        bool success;
         if (currency.isNative()) {
             assembly ("memory-safe") {
                 // Transfer the ETH and revert if it fails.
-                success := call(gas(), to, amount, 0, 0, 0, 0)
+                if iszero(call(gas(), to, amount, 0x00, 0x00, 0x00, 0x00)) {
+                    mstore(0x00, 0xf4b3b1bc) // `NativeTransferFailed()`.
+                    revert(0x1c, 0x04)
+                }
             }
-            if (!success) NativeTransferFailed.selector.revertWith();
         } else {
             assembly ("memory-safe") {
-                // Get a pointer to some free memory.
-                let fmp := mload(0x40)
-
-                // Write the abi-encoded calldata into memory, beginning with the function selector.
-                mstore(fmp, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)
-                mstore(add(fmp, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the "to" argument.
-                mstore(add(fmp, 36), amount) // Append the "amount" argument. Masking not required as it's a full 32 byte type.
-
-                success :=
-                    and(
-                        // Set success to whether the call reverted, if not we check it either
-                        // returned exactly 1 (can't just be non-zero data), or had no return data.
-                        or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),
-                        // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.
-                        // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.
-                        // Counterintuitively, this call must be positioned second to the or() call in the
-                        // surrounding and() call or else returndatasize() will be zero during the computation.
-                        call(gas(), currency, 0, fmp, 68, 0, 32)
+                mstore(0x14, to) // Store the `to` address in [0x20, 0x34).
+                mstore(0x34, amount) // Store the `amount` argument in [0x34, 0x54).
+                // Store the selector of `transfer(address,uint256)` in [0x10, 0x14).
+                // also cleans the upper bits of `to`
+                mstore(0x00, 0xa9059cbb000000000000000000000000)
+                // Perform the transfer, reverting upon failure.
+                if iszero(
+                    and( // The arguments of `and` are evaluated from right to left.
+                        or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.
+                        call(gas(), currency, 0, 0x10, 0x44, 0x00, 0x20)
                     )
-
-                // Now clean the memory we used
-                mstore(fmp, 0) // 4 byte `selector` and 28 bytes of `to` were stored here
-                mstore(add(fmp, 0x20), 0) // 4 bytes of `to` and 28 bytes of `amount` were stored here
-                mstore(add(fmp, 0x40), 0) // 4 bytes of `amount` were stored here
+                ) {
+                    mstore(0x00, 0xf27f64e4) // `ERC20TransferFailed()`.
+                    revert(0x1c, 0x04)
+                }
+                mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.
             }
-            if (!success) ERC20TransferFailed.selector.revertWith();
         }
     }
 
