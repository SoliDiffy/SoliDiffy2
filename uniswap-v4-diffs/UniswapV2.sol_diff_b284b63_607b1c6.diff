diff --git a/contracts/UniswapV2.sol b/contracts/UniswapV2.sol
index ff05162c..ff2c2574 100644
--- a/contracts/UniswapV2.sol
+++ b/contracts/UniswapV2.sol
@@ -1,23 +1,25 @@
 pragma solidity 0.5.12;
-
 import "./interfaces/IUniswapV2.sol";
-
 import "./libraries/Math.sol";
-import "./libraries/UQ128x128.sol";
-
+import "./libraries/SafeMath128.sol";
+import "./libraries/UQ104x104.sol";
 import "./token/ERC20.sol";
 import "./token/SafeTransfer.sol";
 
 contract UniswapV2 is IUniswapV2, ERC20("Uniswap V2", "UNI-V2", 18, 0), SafeTransfer {
+    using SafeMath128 for uint128;
     using SafeMath for uint;
-    using UQ128x128 for uint;
+    using UQ104x104 for uint240;
 
     address public factory;
-    address public token0; address public token1;
-
-    uint128 public reserve0; uint128 public reserve1;
-    uint   public priceCumulative0;         uint public   priceCumulative1;
-    uint64 public priceCumulative0Overflow; uint64 public priceCumulative1Overflow; uint64 public blockNumber;
+    address public token0;
+    address public token1;
+    uint128 public reserve0;
+    uint128 public reserve1;
+    uint240 public priceCumulative0;
+    uint16 public blockNumberHalf0;
+    uint240 public priceCumulative1;
+    uint16 public blockNumberHalf1;
 
     bool private notEntered = true;
     modifier lock() {
@@ -28,21 +30,30 @@ contract UniswapV2 is IUniswapV2, ERC20("Uniswap V2", "UNI-V2", 18, 0), SafeTran
     }
 
     event LiquidityMinted(
-        address indexed sender, address indexed recipient,
-        uint amount0, uint amount1,
-        uint128 reserve0, uint128 reserve1,
+        address indexed sender,
+        address indexed recipient,
+        uint amount0,
+        uint amount1,
+        uint128 reserve0,
+        uint128 reserve,
         uint liquidity
     );
     event LiquidityBurned(
-        address indexed sender, address indexed recipient,
-        uint amount0, uint amount1,
-        uint128 reserve0, uint128 reserve1,
+        address indexed sender,
+        address indexed recipient,
+        uint amount0,
+        uint amount1,
+        uint128 reserve0,
+        uint128 reserve1,
         uint liquidity
     );
     event Swap(
-        address indexed sender, address indexed recipient,
-        uint amount0, uint amount1,
-        uint128 reserve0, uint128 reserve1,
+        address indexed sender,
+        address indexed recipient,
+        uint amount0,
+        uint amount1,
+        uint128 reserve0,
+        uint128 reserve1,
         address input
     );
 
@@ -53,7 +64,16 @@ contract UniswapV2 is IUniswapV2, ERC20("Uniswap V2", "UNI-V2", 18, 0), SafeTran
 
     function initialize(address _token0, address _token1) external {
         require(token0 == address(0) && token1 == address(0), 'UniswapV2: ALREADY_INITIALIZED');
-        (token0, token1) = (_token0, _token1);
+        token0 = _token0;
+        token1 = _token1;
+    }
+
+    function getReserves() external view returns (uint128, uint128) {
+        return (reserve0, reserve1);
+    }
+
+    function readOracleBlockNumber() public view returns (uint32) {
+        return (uint32(blockNumberHalf0) << 16) + blockNumberHalf1;
     }
 
     // uniswap-v1 naming
@@ -66,19 +86,30 @@ contract UniswapV2 is IUniswapV2, ERC20("Uniswap V2", "UNI-V2", 18, 0), SafeTran
     }
 
     function update(uint balance0, uint balance1) private {
-        if (block.number > blockNumber) {
+        uint32 blockNumberLast = readOracleBlockNumber();
+
+        // if any blocks have gone by since the last time this function was called, we have to update
+        if (block.number > blockNumberLast) {
+            // we have to ensure that neither reserves are 0, else our price division fails
             if (reserve0 != 0 && reserve1 != 0) {
-                uint64 blocksElapsed = uint64(block.number) - blockNumber; // doesn't overflow until >the end of time
-                (uint p0, uint64 po0) = Math.mul512(UQ128x128.encode(reserve0).qdiv(reserve1), blocksElapsed);
-                (uint p1, uint64 po1) = Math.mul512(UQ128x128.encode(reserve1).qdiv(reserve0), blocksElapsed);
-                uint64 pc0o; uint64 pc1o;
-                (priceCumulative0, pc0o) = Math.add512(priceCumulative0, priceCumulative0Overflow, p0, po0);
-                (priceCumulative1, pc1o) = Math.add512(priceCumulative1, priceCumulative1Overflow, p1, po1);
-                (priceCumulative0Overflow, priceCumulative1Overflow) = (pc0o, pc1o);
+                // get the prices according to the reserves as of the last official interaction with the contract
+                uint240 price0 = UQ104x104.encode(reserve0).qdiv(reserve1);
+                uint240 price1 = UQ104x104.encode(reserve1).qdiv(reserve0);
+
+                // multiply these prices by the number of elapsed blocks and add to the accumulators
+                uint32 blocksElapsed = block.number.downcast32() - blockNumberLast;
+                priceCumulative0 += price0 * blocksElapsed;
+                priceCumulative1 += price1 * blocksElapsed;
             }
-            blockNumber = uint64(block.number); // doesn't overflow until >the end of time
+
+            // update the last block number
+            blockNumberHalf0 = uint16(block.number >> 16);
+            blockNumberHalf1 = uint16(block.number);
         }
-        (reserve0, reserve1) = (balance0.clamp128(), balance1.clamp128()); // update reserves
+
+        // update reserves
+        reserve0 = balance0.clamp128();
+        reserve1 = balance1.clamp128();
     }
 
     function mintLiquidity(address recipient) external lock returns (uint liquidity) {
@@ -92,7 +123,6 @@ contract UniswapV2 is IUniswapV2, ERC20("Uniswap V2", "UNI-V2", 18, 0), SafeTran
             Math.min(amount0.mul(totalSupply) / reserve0, amount1.mul(totalSupply) / reserve1);
         require(liquidity > 0, "UniswapV2: INSUFFICIENT_VALUE");
         mint(recipient, liquidity);
-
         update(balance0, balance1);
         emit LiquidityMinted(msg.sender, recipient, amount0, amount1, reserve0, reserve1, liquidity);
     }
@@ -100,73 +130,60 @@ contract UniswapV2 is IUniswapV2, ERC20("Uniswap V2", "UNI-V2", 18, 0), SafeTran
     function burnLiquidity(address recipient) external lock returns (uint amount0, uint amount1) {
         uint liquidity = balanceOf[address(this)];
         require(liquidity > 0, "UniswapV2: INSUFFICIENT_VALUE");
-
         amount0 = liquidity.mul(reserve0) / totalSupply;
         amount1 = liquidity.mul(reserve1) / totalSupply;
         require(amount0 > 0 && amount1 > 0, "UniswapV2: INSUFFICIENT_VALUE");
         safeTransfer(token0, recipient, amount0);
         safeTransfer(token1, recipient, amount1);
-
         update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)));
         emit LiquidityBurned(msg.sender, recipient, amount0, amount1, reserve0, reserve1, liquidity);
     }
 
     function swap0(address recipient) external lock returns (uint amount1) {
         uint balance0 = IERC20(token0).balanceOf(address(this));
-        uint amount0 = balance0.sub(reserve0); // this can fail for weird tokens, hence sync
-
+        uint amount0 = balance0.sub(reserve0); // this can fail
         require(amount0 > 0, "UniswapV2: INSUFFICIENT_VALUE_INPUT");
         amount1 = getInputPrice(amount0, reserve0, reserve1);
         require(amount1 > 0, "UniswapV2: INSUFFICIENT_VALUE_OUTPUT");
         safeTransfer(token1, recipient, amount1);
-
         update(balance0, IERC20(token1).balanceOf(address(this)));
         emit Swap(msg.sender, recipient, amount0, amount1, reserve0, reserve1, token0);
     }
 
     function swap1(address recipient) external lock returns (uint amount0) {
         uint balance1 = IERC20(token1).balanceOf(address(this));
-        uint amount1 = balance1.sub(reserve1); // this can fail for weird tokens, hence sync
-
+        uint amount1 = balance1.sub(reserve1); // this can fail
         require(amount1 > 0, "UniswapV2: INSUFFICIENT_VALUE_INPUT");
         amount0 = getInputPrice(amount1, reserve1, reserve0);
         require(amount0 > 0, "UniswapV2: INSUFFICIENT_VALUE_OUTPUT");
         safeTransfer(token0, recipient, amount0);
-
         update(IERC20(token0).balanceOf(address(this)), balance1);
         emit Swap(msg.sender, recipient, amount0, amount1, reserve0, reserve1, token1);
     }
 
-    // this function almost certainly never needs to be called, it's for weird token
     function sync() external lock {
         update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)));
     }
 
-    // DONT CALL THIS FUNCTION UNLESS token0 IS PERMANENTLY BROKEN
+    // DONT CALL THIS FUNCTION UNLESS token0 IS PERMANENTLY BROKEN // TODO: counterfactual
     function unsafeRageQuit0(address recipient) external lock returns (uint amount1) {
         uint liquidity = balanceOf[address(this)];
         require(liquidity > 0, "UniswapV2: INSUFFICIENT_VALUE");
-
-        uint amount0 = liquidity.mul(reserve0) / totalSupply;
         amount1 = liquidity.mul(reserve1) / totalSupply;
-        require(amount0 > 0 && amount1 > 0, "UniswapV2: INSUFFICIENT_VALUE");
+        require(amount1 > 0, "UniswapV2: INSUFFICIENT_VALUE");
         safeTransfer(token1, recipient, amount1);
-
-        update(IERC20(token0).balanceOf(address(this)).sub(amount0), IERC20(token1).balanceOf(address(this)));
+        update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)));
         emit LiquidityBurned(msg.sender, recipient, 0, amount1, reserve0, reserve1, liquidity);
     }
 
-    // DONT CALL THIS FUNCTION UNLESS token1 IS PERMANENTLY BROKEN
+    // DONT CALL THIS FUNCTION UNLESS token1 IS PERMANENTLY BROKEN // TODO: counterfactual
     function unsafeRageQuit1(address recipient) external lock returns (uint amount0) {
         uint liquidity = balanceOf[address(this)];
         require(liquidity > 0, "UniswapV2: INSUFFICIENT_VALUE");
-
         amount0 = liquidity.mul(reserve0) / totalSupply;
-        uint amount1 = liquidity.mul(reserve1) / totalSupply;
-        require(amount0 > 0 && amount1 > 0, "UniswapV2: INSUFFICIENT_VALUE");
+        require(amount0 > 0, "UniswapV2: INSUFFICIENT_VALUE");
         safeTransfer(token0, recipient, amount0);
-
-        update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)).sub(amount1));
+        update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)));
         emit LiquidityBurned(msg.sender, recipient, amount0, 0, reserve0, reserve1, liquidity);
     }
 }
