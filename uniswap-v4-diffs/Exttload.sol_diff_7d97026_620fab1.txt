diff --git a/src/Exttload.sol b/src/Exttload.sol
index 44d46aab..251db04a 100644
--- a/src/Exttload.sol
+++ b/src/Exttload.sol
@@ -7,10 +7,11 @@ import {IExttload} from "./interfaces/IExttload.sol";
 /// https://eips.ethereum.org/EIPS/eip-2330#rationale
 abstract contract Exttload is IExttload {
     /// @inheritdoc IExttload
-    function exttload(bytes32 slot) external view returns (bytes32 value) {
+    function exttload(bytes32 slot) external view returns (bytes32) {
         /// @solidity memory-safe-assembly
         assembly {
-            value := tload(slot)
+            mstore(0, tload(slot))
+            return(0, 0x20)
         }
     }
 
@@ -19,19 +20,21 @@ abstract contract Exttload is IExttload {
         // since the function is external and enters a new call context and exits right
         // after execution, Solidity's memory management convention can be disregarded
         // and a direct slice of memory can be returned
-        assembly ("memory-safe") {
-            // abi offset for dynamic array
-            mstore(0, 0x20)
-            mstore(0x20, slots.length)
+        /// @solidity memory-safe-assembly
+        assembly {
+            // Copy the abi offset of dynamic array and the length of the array to memory.
+            calldatacopy(0, 0x04, 0x40)
+            // A left bit-shift of 5 is equivalent to multiplying by 32 but costs less gas.
             let end := add(0x40, shl(5, slots.length))
-            let memptr := 0x40
             let calldataptr := slots.offset
-            for {} 1 {} {
+            // Return values will start at 64 while calldata offset is 68.
+            for { let memptr := 0x40 } 1 {} {
                 mstore(memptr, tload(calldataload(calldataptr)))
                 memptr := add(memptr, 0x20)
                 calldataptr := add(calldataptr, 0x20)
                 if iszero(lt(memptr, end)) { break }
             }
+            // The end offset is also the length of the returndata.
             return(0, end)
         }
     }
