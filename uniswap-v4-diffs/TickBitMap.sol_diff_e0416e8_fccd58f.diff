diff --git a/contracts/libraries/TickBitMap.sol b/contracts/libraries/TickBitMap.sol
index bd093898..ce80745d 100644
--- a/contracts/libraries/TickBitMap.sol
+++ b/contracts/libraries/TickBitMap.sol
@@ -3,27 +3,33 @@ pragma solidity >=0.5.0;
 
 import '@uniswap/lib/contracts/libraries/BitMath.sol';
 
-// a library for dealing with a bitmap of all ticks initialized states, represented as mapping(int16 => uint256)
-// the mapping uses int16 for keys since ticks are represented as int24 and there are 256 (2^8) bits per word
+// a library for dealing with a bitmap of all ticks initialized states, represented as mapping(uint256 => uint256)
+// the tick's initialization bit position in this map is computed by:
+// word: (tick - type(int24).min) / 256
+// bit in word: (tick - type(int24).min) % 256
+// mask: uint256(1) << (tick - type(int24).min) % 256
 library TickBitMap {
-    // computes the position in the mapping where the initialized bit for a tick lives
-    // wordPos is the position in the mapping containing the word in which the bit is set
-    // bitPos is the position in the word from most to least significant where the flag is set
-    function position(int24 tick) private pure returns (int16 wordPos, uint8 bitPos) {
-        wordPos = int16(tick >> 8);
-        bitPos = uint8(255) - uint8(tick % 256);
+    // computes the position in the uint256 array where the initialized state for a tick lives
+    // bitPos is the 0 indexed position in the word from most to least significant where the flag is set
+    function position(int24 tick) private pure returns (uint256 wordPos, uint256 bitPos) {
+        // moves the tick into positive integer space while making sure all ticks are adjacent
+        uint256 bitIndex = uint256(
+            int256(tick) + 8388608 /* equivalent to -type(int24).min */
+        );
+        wordPos = bitIndex / 256;
+        bitPos = 255 - (bitIndex % 256);
     }
 
     // returns whether the given tick is initialized
-    function isInitialized(mapping(int16 => uint256) storage self, int24 tick) internal view returns (bool) {
-        (int16 wordPos, uint8 bitPos) = position(tick);
+    function isInitialized(mapping(uint256 => uint256) storage self, int24 tick) internal view returns (bool) {
+        (uint256 wordPos, uint256 bitPos) = position(tick);
         uint256 mask = uint256(1) << bitPos;
         return self[wordPos] & mask != 0;
     }
 
     // flips the tick from uninitialized to initialized, or vice versa
-    function flipTick(mapping(int16 => uint256) storage self, int24 tick) internal {
-        (int16 wordPos, uint8 bitPos) = position(tick);
+    function flipTick(mapping(uint256 => uint256) storage self, int24 tick) internal {
+        (uint256 wordPos, uint256 bitPos) = position(tick);
         uint256 mask = uint256(1) << bitPos;
         self[wordPos] ^= mask;
     }
@@ -31,12 +37,12 @@ library TickBitMap {
     // returns the next initialized tick contained in the same word as the current tick that is either lte this tick
     // or greater than this tick
     function nextInitializedTickWithinOneWord(
-        mapping(int16 => uint256) storage self,
+        mapping(uint256 => uint256) storage self,
         int24 tick,
         bool lte
     ) internal view returns (int24 next, bool initialized) {
         if (lte) {
-            (int16 wordPos, uint8 bitPos) = position(tick);
+            (uint256 wordPos, uint256 bitPos) = position(tick);
             uint256 word = self[wordPos];
             // all the 1s at or to the left of the current bitPos
             uint256 mask = uint256(-1) - ((uint256(1) << bitPos) - 1);
@@ -48,7 +54,7 @@ library TickBitMap {
             return (tick + (int24(bitPos) - int24(BitMath.leastSignificantBit(masked))), true);
         } else {
             // start from the word of the next tick, since the current tick state doesn't matter
-            (int16 wordPos, uint8 bitPos) = position(tick + 1);
+            (uint256 wordPos, uint256 bitPos) = position(tick + 1);
             uint256 word = self[wordPos];
             // all the 1s at or to the right of the bitPos
             uint256 mask = bitPos == 255 ? uint256(-1) : (uint256(1) << (bitPos + 1)) - 1;
@@ -63,7 +69,7 @@ library TickBitMap {
 
     // same as above, but iterates until it finds the next initialized tick
     function nextInitializedTick(
-        mapping(int16 => uint256) storage self,
+        mapping(uint256 => uint256) storage self,
         int24 tick,
         bool lte,
         int24 minOrMax
