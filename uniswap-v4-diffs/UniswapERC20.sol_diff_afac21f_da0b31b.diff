diff --git a/contracts/UniswapERC20.sol b/contracts/UniswapERC20.sol
index b01da411..5099e305 100644
--- a/contracts/UniswapERC20.sol
+++ b/contracts/UniswapERC20.sol
@@ -1,5 +1,6 @@
 pragma solidity ^0.5.11;
 import './ERC20.sol';
+import './Math.sol';
 import './interfaces/IERC20.sol';
 
 contract UniswapERC20 is ERC20 {
@@ -93,11 +94,7 @@ contract UniswapERC20 is ERC20 {
       return amountBought;
   }
 
-  function min(uint256 a, uint256 b) internal pure returns (uint256) {
-      return a < b ? a : b;
-  }
-
-  function addLiquidity(address recipient) public nonReentrant returns (uint256) {
+  function addLiquidity() public nonReentrant returns (uint256) {
     uint256 _totalSupply = totalSupply;
 
     address _tokenA = tokenA;
@@ -121,15 +118,11 @@ contract UniswapERC20 is ERC20 {
     uint256 liquidityMinted;
 
     if (_totalSupply > 0) {
-      require(oldReserveA > 0, "INVALID_TOKEN_A_RESERVE");
-      require(oldReserveB > 0, "INVALID_TOKEN_B_RESERVE");
-      // TODO: take the geometric mean instead of the min?? equivalently sqrt(newK / oldK) * _totalSupply
-      liquidityMinted = min((amountA.mul(_totalSupply) / oldReserveA), (amountB.mul(_totalSupply) / oldReserveB));
+      liquidityMinted = Math.min((amountA.mul(_totalSupply).div(oldReserveA)), (amountB.mul(_totalSupply).div(oldReserveB)));
     } else {
-      // TODO: figure out how to set this safely (arithmetic or geometric mean?)
-      liquidityMinted = amountA;
+      liquidityMinted = Math.sqrt(amountA.mul(amountB));
     }
-    balanceOf[recipient] = balanceOf[recipient].add(liquidityMinted);
+    balanceOf[msg.sender] = balanceOf[msg.sender].add(liquidityMinted);
     totalSupply = _totalSupply.add(liquidityMinted);
 
     dataForToken[_tokenA] = TokenData({
@@ -149,7 +142,7 @@ contract UniswapERC20 is ERC20 {
   }
 
 
-  function removeLiquidity(uint256 amount, address recipient) public nonReentrant returns (uint256, uint256) {
+  function removeLiquidity(uint256 amount) public nonReentrant returns (uint256, uint256) {
     require(amount > 0);
     address _tokenA = tokenA;
     address _tokenB = tokenB;
@@ -164,8 +157,8 @@ contract UniswapERC20 is ERC20 {
     uint256 tokenBAmount = amount.mul(reserveB) / _totalSupply;
     balanceOf[msg.sender] = balanceOf[msg.sender].sub(amount);
     totalSupply = _totalSupply.sub(amount);
-    require(IERC20(_tokenA).transfer(recipient, tokenAAmount));
-    require(IERC20(_tokenB).transfer(recipient, tokenBAmount));
+    require(IERC20(_tokenA).transfer(msg.sender, tokenAAmount));
+    require(IERC20(_tokenB).transfer(msg.sender, tokenBAmount));
 
     dataForToken[_tokenA] = TokenData({
       reserve: uint128(reserveA - tokenAAmount),
