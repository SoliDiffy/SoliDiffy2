diff --git a/src/Extsload.sol b/src/Extsload.sol
index 0b5e321e..16e5028d 100644
--- a/src/Extsload.sol
+++ b/src/Extsload.sol
@@ -1,5 +1,5 @@
 // SPDX-License-Identifier: MIT
-pragma solidity ^0.8.0;
+pragma solidity >=0.6.0;
 
 import {IExtsload} from "./interfaces/IExtsload.sol";
 
@@ -17,42 +17,46 @@ abstract contract Extsload is IExtsload {
     /// @inheritdoc IExtsload
     function extsload(bytes32 startSlot, uint256 nSlots) external view returns (bytes memory) {
         assembly ("memory-safe") {
-            // The abi offset of dynamic array in the returndata is 32.
-            mstore(0, 0x20)
+            let memptr := mload(0x40)
+            let start := memptr
             // A left bit-shift of 5 is equivalent to multiplying by 32 but costs less gas.
-            mstore(0x20, shl(5, nSlots))
-            let end := add(0x40, shl(5, nSlots))
-            for { let memptr := 0x40 } 1 {} {
+            let length := shl(5, nSlots)
+            // The abi offset of dynamic array in the returndata is 32.
+            mstore(memptr, 0x20)
+            // Store the length of the bytes returned
+            mstore(add(memptr, 0x20), length)
+            // update memptr to the first location to hold a result
+            memptr := add(memptr, 0x40)
+            let end := add(memptr, length)
+            for {} 1 {} {
                 mstore(memptr, sload(startSlot))
                 memptr := add(memptr, 0x20)
                 startSlot := add(startSlot, 1)
                 if iszero(lt(memptr, end)) { break }
             }
-            // The end offset is also the length of the returndata.
-            return(0, end)
+            return(start, sub(end, start))
         }
     }
 
     /// @inheritdoc IExtsload
     function extsload(bytes32[] calldata slots) external view returns (bytes32[] memory) {
-        // since the function is external and enters a new call context and exits right
-        // after execution, Solidity's memory management convention can be disregarded
-        // and a direct slice of memory can be returned
         assembly ("memory-safe") {
+            let memptr := mload(0x40)
+            let start := memptr
             // Copy the abi offset of dynamic array and the length of the array to memory.
-            calldatacopy(0, 0x04, 0x40)
+            calldatacopy(memptr, 0x04, 0x40)
+            // update memptr to the first location to hold a result
+            memptr := add(memptr, 0x40)
             // A left bit-shift of 5 is equivalent to multiplying by 32 but costs less gas.
-            let end := add(0x40, shl(5, slots.length))
+            let end := add(memptr, shl(5, slots.length))
             let calldataptr := slots.offset
-            // Return values will start at 64 while calldata offset is 68.
-            for { let memptr := 0x40 } 1 {} {
+            for {} 1 {} {
                 mstore(memptr, sload(calldataload(calldataptr)))
                 memptr := add(memptr, 0x20)
                 calldataptr := add(calldataptr, 0x20)
                 if iszero(lt(memptr, end)) { break }
             }
-            // The end offset is also the length of the returndata.
-            return(0, end)
+            return(start, sub(end, start))
         }
     }
 }
