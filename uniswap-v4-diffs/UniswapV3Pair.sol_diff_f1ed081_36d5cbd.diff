diff --git a/contracts/UniswapV3Pair.sol b/contracts/UniswapV3Pair.sol
index 96513ba0..7ad7428c 100644
--- a/contracts/UniswapV3Pair.sol
+++ b/contracts/UniswapV3Pair.sol
@@ -13,15 +13,15 @@ import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
 import './libraries/SafeCast.sol';
 import './libraries/MixedSafeMath.sol';
 import './libraries/PriceMath.sol';
-import './libraries/TickMath.sol';
 
 import './interfaces/IUniswapV3Pair.sol';
 import './interfaces/IUniswapV3Factory.sol';
 import './interfaces/IUniswapV3Callee.sol';
-import './libraries/SpacedTickBitmap.sol';
+import './libraries/TickBitmap.sol';
 import './libraries/FixedPoint128.sol';
+import './TickMath1r01.sol';
 
-contract UniswapV3Pair is IUniswapV3Pair {
+contract UniswapV3Pair is IUniswapV3Pair, TickMath1r01 {
     using SafeMath for uint128;
     using SafeMath for uint256;
     using SignedSafeMath for int128;
@@ -30,7 +30,7 @@ contract UniswapV3Pair is IUniswapV3Pair {
     using SafeCast for uint256;
     using MixedSafeMath for uint128;
     using FixedPoint128 for FixedPoint128.uq128x128;
-    using SpacedTickBitmap for mapping(int16 => uint256);
+    using TickBitmap for mapping(int16 => uint256);
 
     // if we constrain the liquidity associated to a single tick, then we can guarantee that the total
     // liquidityCurrent never exceeds uint128
@@ -45,16 +45,7 @@ contract UniswapV3Pair is IUniswapV3Pair {
     address public immutable override token1;
     uint24 public immutable override fee;
 
-    // how far apart initialized ticks must be
-    // e.g. a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e. ..., -6, -3, 0, 3, 6, ...
-    // int24 to avoid casting even though it's always positive
-    int24 public immutable override tickSpacing;
-
-    // the minimum and maximum tick for the pair
-    // always a multiple of tickSpacing
-    int24 public immutable override MIN_TICK;
-    int24 public immutable override MAX_TICK;
-
+    // TODO figure out the best way to pack state variables
     address public override feeTo;
 
     // see TickBitmap.sol
@@ -123,7 +114,7 @@ contract UniswapV3Pair is IUniswapV3Pair {
 
     function _getFeeGrowthBelow(
         int24 tick,
-        int24 current,
+        int24 tickCurrent,
         TickInfo storage tickInfo
     )
         private
@@ -131,7 +122,7 @@ contract UniswapV3Pair is IUniswapV3Pair {
         returns (FixedPoint128.uq128x128 memory feeGrowthBelow0, FixedPoint128.uq128x128 memory feeGrowthBelow1)
     {
         // tick is above the current tick, meaning growth outside represents growth above, not below
-        if (tick > current) {
+        if (tick > tickCurrent) {
             feeGrowthBelow0 = FixedPoint128.uq128x128(feeGrowthGlobal0._x - tickInfo.feeGrowthOutside0._x);
             feeGrowthBelow1 = FixedPoint128.uq128x128(feeGrowthGlobal1._x - tickInfo.feeGrowthOutside1._x);
         } else {
@@ -142,7 +133,7 @@ contract UniswapV3Pair is IUniswapV3Pair {
 
     function _getFeeGrowthAbove(
         int24 tick,
-        int24 current,
+        int24 tickCurrent,
         TickInfo storage tickInfo
     )
         private
@@ -150,7 +141,7 @@ contract UniswapV3Pair is IUniswapV3Pair {
         returns (FixedPoint128.uq128x128 memory feeGrowthAbove0, FixedPoint128.uq128x128 memory feeGrowthAbove1)
     {
         // tick is above current tick, meaning growth outside represents growth above
-        if (tick > current) {
+        if (tick > tickCurrent) {
             feeGrowthAbove0 = tickInfo.feeGrowthOutside0;
             feeGrowthAbove1 = tickInfo.feeGrowthOutside1;
         } else {
@@ -162,7 +153,7 @@ contract UniswapV3Pair is IUniswapV3Pair {
     function _getFeeGrowthInside(
         int24 tickLower,
         int24 tickUpper,
-        int24 current,
+        int24 tickCurrent,
         TickInfo storage tickInfoLower,
         TickInfo storage tickInfoUpper
     )
@@ -173,11 +164,11 @@ contract UniswapV3Pair is IUniswapV3Pair {
         (
             FixedPoint128.uq128x128 memory feeGrowthBelow0,
             FixedPoint128.uq128x128 memory feeGrowthBelow1
-        ) = _getFeeGrowthBelow(tickLower, current, tickInfoLower);
+        ) = _getFeeGrowthBelow(tickLower, tickCurrent, tickInfoLower);
         (
             FixedPoint128.uq128x128 memory feeGrowthAbove0,
             FixedPoint128.uq128x128 memory feeGrowthAbove1
-        ) = _getFeeGrowthAbove(tickUpper, current, tickInfoUpper);
+        ) = _getFeeGrowthAbove(tickUpper, tickCurrent, tickInfoUpper);
         feeGrowthInside0 = FixedPoint128.uq128x128(feeGrowthGlobal0._x - feeGrowthBelow0._x - feeGrowthAbove0._x);
         feeGrowthInside1 = FixedPoint128.uq128x128(feeGrowthGlobal1._x - feeGrowthBelow1._x - feeGrowthAbove1._x);
     }
@@ -187,26 +178,16 @@ contract UniswapV3Pair is IUniswapV3Pair {
         return priceCurrent._x != 0; // sufficient check
     }
 
-    function tickCurrent() public view override returns (int24) {
-        return TickMath.getTickAtRatio(priceCurrent._x);
-    }
-
     constructor(
         address _factory,
         address _token0,
         address _token1,
-        uint24 _fee,
-        int24 _tickSpacing
+        uint24 _fee
     ) public {
-        require(_tickSpacing > 0, 'UniswapV3Pair::constructor: _tickSpacing must be greater than 0');
-
         factory = _factory;
         token0 = _token0;
         token1 = _token1;
         fee = _fee;
-        tickSpacing = _tickSpacing;
-        MIN_TICK = (TickMath.MIN_TICK / _tickSpacing) * _tickSpacing;
-        MAX_TICK = (TickMath.MAX_TICK / _tickSpacing) * _tickSpacing;
     }
 
     // returns the block timestamp % 2**64
@@ -240,7 +221,7 @@ contract UniswapV3Pair is IUniswapV3Pair {
         if (blockTimestampLast != blockTimestamp) {
             uint32 timeElapsed = blockTimestamp - blockTimestampLast;
             liquidityCumulative = liquidityCumulativeLast + uint160(timeElapsed) * liquidityCurrent;
-            tickCumulative = tickCumulativeLast + int56(timeElapsed) * TickMath.getTickAtRatio(priceCurrent._x);
+            tickCumulative = tickCumulativeLast + int56(timeElapsed) * getTickAtRatio(priceCurrent._x);
         } else {
             return (blockTimestamp, liquidityCumulativeLast, tickCumulativeLast);
         }
@@ -253,7 +234,7 @@ contract UniswapV3Pair is IUniswapV3Pair {
 
     function _updateTick(
         int24 tick,
-        int24 current,
+        int24 tickCurrent,
         int128 liquidityDelta
     ) private returns (TickInfo storage tickInfo) {
         tickInfo = tickInfos[tick];
@@ -261,14 +242,14 @@ contract UniswapV3Pair is IUniswapV3Pair {
         if (tickInfo.liquidityGross == 0) {
             assert(liquidityDelta > 0);
             // by convention, we assume that all growth before a tick was initialized happened _below_ the tick
-            if (tick <= current) {
+            if (tick <= tickCurrent) {
                 tickInfo.feeGrowthOutside0 = feeGrowthGlobal0;
                 tickInfo.feeGrowthOutside1 = feeGrowthGlobal1;
                 tickInfo.secondsOutside = _blockTimestamp();
             }
             // safe because we know liquidityDelta is > 0
             tickInfo.liquidityGross = uint128(liquidityDelta);
-            tickBitmap.flipTick(tick, tickSpacing);
+            tickBitmap.flipTick(tick);
         } else {
             tickInfo.liquidityGross = uint128(tickInfo.liquidityGross.addi(liquidityDelta));
         }
@@ -276,7 +257,7 @@ contract UniswapV3Pair is IUniswapV3Pair {
 
     function _clearTick(int24 tick) private {
         delete tickInfos[tick];
-        tickBitmap.flipTick(tick, tickSpacing);
+        tickBitmap.flipTick(tick);
     }
 
     function initialize(uint256 price) external override lock {
@@ -312,10 +293,6 @@ contract UniswapV3Pair is IUniswapV3Pair {
         require(tickLower < tickUpper, 'UniswapV3Pair::setPosition: tickLower must be less than tickUpper');
         require(tickLower >= MIN_TICK, 'UniswapV3Pair::setPosition: tickLower cannot be less than min tick');
         require(tickUpper <= MAX_TICK, 'UniswapV3Pair::setPosition: tickUpper cannot be greater than max tick');
-        require(
-            tickLower % tickSpacing == 0 && tickUpper % tickSpacing == 0,
-            'UniswapV3Pair::setPosition: tickLower and tickUpper must be multiples of tickSpacing'
-        );
 
         return
             _setPosition(
@@ -328,7 +305,7 @@ contract UniswapV3Pair is IUniswapV3Pair {
             );
     }
 
-    function _updatePosition(SetPositionParams memory params, int24 tick)
+    function _updatePosition(SetPositionParams memory params, int24 tickCurrent)
         private
         returns (uint256 feesOwed0, uint256 feesOwed1)
     {
@@ -346,8 +323,8 @@ contract UniswapV3Pair is IUniswapV3Pair {
             );
         }
 
-        TickInfo storage tickInfoLower = _updateTick(params.tickLower, tick, params.liquidityDelta);
-        TickInfo storage tickInfoUpper = _updateTick(params.tickUpper, tick, params.liquidityDelta);
+        TickInfo storage tickInfoLower = _updateTick(params.tickLower, tickCurrent, params.liquidityDelta);
+        TickInfo storage tickInfoUpper = _updateTick(params.tickUpper, tickCurrent, params.liquidityDelta);
 
         require(
             tickInfoLower.liquidityGross <= MAX_LIQUIDITY_GROSS_PER_TICK,
@@ -362,7 +339,7 @@ contract UniswapV3Pair is IUniswapV3Pair {
             (
                 FixedPoint128.uq128x128 memory feeGrowthInside0,
                 FixedPoint128.uq128x128 memory feeGrowthInside1
-            ) = _getFeeGrowthInside(params.tickLower, params.tickUpper, tick, tickInfoLower, tickInfoUpper);
+            ) = _getFeeGrowthInside(params.tickLower, params.tickUpper, tickCurrent, tickInfoLower, tickInfoUpper);
 
             // check if this condition has accrued any untracked fees and credit them to the caller
             if (position.liquidity > 0) {
@@ -428,36 +405,36 @@ contract UniswapV3Pair is IUniswapV3Pair {
     function _setPosition(SetPositionParams memory params) private returns (int256 amount0, int256 amount1) {
         _updateAccumulators();
 
-        int24 tick = tickCurrent();
+        int24 tickCurrent = getTickAtRatio(priceCurrent._x);
 
         // how many fees are owed to the position owner
-        (uint256 feesOwed0, uint256 feesOwed1) = _updatePosition(params, tick);
+        (uint256 feesOwed0, uint256 feesOwed1) = _updatePosition(params, tickCurrent);
 
         // the current price is below the passed range, so the liquidity can only become in range by crossing from left
         // to right, at which point we'll need _more_ token0 (it's becoming more valuable) so the user must provide it
-        if (tick < params.tickLower) {
+        if (tickCurrent < params.tickLower) {
             amount0 = PriceMath
                 .getAmount0Delta(
-                FixedPoint128.uq128x128(TickMath.getRatioAtTick(params.tickLower)),
-                FixedPoint128.uq128x128(TickMath.getRatioAtTick(params.tickUpper)),
+                FixedPoint128.uq128x128(getRatioAtTick(params.tickLower)),
+                FixedPoint128.uq128x128(getRatioAtTick(params.tickUpper)),
                 params
                     .liquidityDelta
             )
                 .sub(feesOwed0.toInt256());
             amount1 = -feesOwed1.toInt256();
-        } else if (tick < params.tickUpper) {
+        } else if (tickCurrent < params.tickUpper) {
             // the current price is inside the passed range
             amount0 = PriceMath
                 .getAmount0Delta(
                 priceCurrent,
-                FixedPoint128.uq128x128(TickMath.getRatioAtTick(params.tickUpper)),
+                FixedPoint128.uq128x128(getRatioAtTick(params.tickUpper)),
                 params
                     .liquidityDelta
             )
                 .sub(feesOwed0.toInt256());
             amount1 = PriceMath
                 .getAmount1Delta(
-                FixedPoint128.uq128x128(TickMath.getRatioAtTick(params.tickLower)),
+                FixedPoint128.uq128x128(getRatioAtTick(params.tickLower)),
                 priceCurrent,
                 params
                     .liquidityDelta
@@ -471,8 +448,8 @@ contract UniswapV3Pair is IUniswapV3Pair {
             // to left, at which point we need _more_ token1 (it's becoming more valuable) so the user must provide it
             amount1 = PriceMath
                 .getAmount1Delta(
-                FixedPoint128.uq128x128(TickMath.getRatioAtTick(params.tickLower)),
-                FixedPoint128.uq128x128(TickMath.getRatioAtTick(params.tickUpper)),
+                FixedPoint128.uq128x128(getRatioAtTick(params.tickLower)),
+                FixedPoint128.uq128x128(getRatioAtTick(params.tickUpper)),
                 params
                     .liquidityDelta
             )
@@ -484,8 +461,6 @@ contract UniswapV3Pair is IUniswapV3Pair {
     }
 
     struct SwapParams {
-        // the tick where the price starts
-        int24 tickStart;
         // whether the swap is from token 0 to 1, or 1 for 0
         bool zeroForOne;
         // how much is being swapped in
@@ -511,7 +486,7 @@ contract UniswapV3Pair is IUniswapV3Pair {
     }
 
     struct StepComputations {
-        // the next initialized tick from the current tick in the swap direction
+        // the next initialized tick from the tickCurrent in the swap direction
         int24 tickNext;
         // price for the target tick (1/0)
         FixedPoint128.uq128x128 priceNext;
@@ -525,19 +500,10 @@ contract UniswapV3Pair is IUniswapV3Pair {
         uint256 amountOut;
     }
 
-    // returns the closest parent tick that could be initialized
-    // the parent tick is the tick s.t. the input tick is gte parent tick and lt parent tick + tickSpacing
-    function closestTick(int24 tick) private view returns (int24) {
-        int24 compressed = tick / tickSpacing;
-        // round towards negative infinity
-        if (tick < 0 && tick % tickSpacing != 0) compressed--;
-        return compressed * tickSpacing;
-    }
-
     function _swap(SwapParams memory params) private returns (uint256 amountOut) {
         SwapState memory state = SwapState({
             amountInRemaining: params.amountIn,
-            tick: params.tickStart,
+            tick: getTickAtRatio(priceCurrent._x),
             price: priceCurrent,
             feeGrowthGlobal: params.zeroForOne ? feeGrowthGlobal0 : feeGrowthGlobal1,
             liquidityCurrent: liquidityCurrent
@@ -546,17 +512,10 @@ contract UniswapV3Pair is IUniswapV3Pair {
         while (state.amountInRemaining > 0) {
             StepComputations memory step;
 
-            (step.tickNext, ) = tickBitmap.nextInitializedTickWithinOneWord(
-                closestTick(state.tick),
-                params.zeroForOne,
-                tickSpacing
-            );
-
-            if (params.zeroForOne) require(step.tickNext >= MIN_TICK, 'UniswapV3Pair::_swap: crossed min tick');
-            else require(step.tickNext <= MAX_TICK, 'UniswapV3Pair::_swap: crossed max tick');
+            (step.tickNext, ) = tickBitmap.nextInitializedTickWithinOneWord(state.tick, params.zeroForOne);
 
             // get the price for the next tick we're moving toward
-            step.priceNext = FixedPoint128.uq128x128(TickMath.getRatioAtTick(step.tickNext));
+            step.priceNext = FixedPoint128.uq128x128(getRatioAtTick(step.tickNext));
 
             // it should always be the case that if params.zeroForOne is true, we should be at or above the target price
             // similarly, if it's false we should be below the target price
@@ -669,19 +628,21 @@ contract UniswapV3Pair is IUniswapV3Pair {
                 // after swapping the remaining amount in
                 state.tick = params.zeroForOne ? step.tickNext - 1 : step.tickNext;
             } else {
-                // todo: this getTickAtRatio call may not be necessary, since we only use it to determine if we crossed a tick
-                state.tick = TickMath.getTickAtRatio(state.price._x);
+                state.tick = getTickAtRatio(state.price._x);
             }
         }
 
-        if (state.tick != params.tickStart) {
-            // must be called before updating the price or liquidity
+        // TODO could probably be optimized
+        if (state.tick != getTickAtRatio(priceCurrent._x)) {
             _updateAccumulators();
             liquidityCurrent = state.liquidityCurrent;
         }
 
         priceCurrent = state.price;
 
+        if (params.zeroForOne) require(state.tick >= MIN_TICK, 'UniswapV3Pair::_swap: crossed min tick');
+        else require(state.tick < MAX_TICK, 'UniswapV3Pair::_swap: crossed max tick');
+
         if (params.zeroForOne) {
             feeGrowthGlobal0 = state.feeGrowthGlobal;
         } else {
@@ -712,7 +673,8 @@ contract UniswapV3Pair is IUniswapV3Pair {
     ) external override lock returns (uint256 amount1Out) {
         require(amount0In > 0, 'UniswapV3Pair::swap0For1: amountIn must be greater than 0');
 
-        return _swap(SwapParams({tickStart: tickCurrent(), zeroForOne: true, amountIn: amount0In, to: to, data: data}));
+        SwapParams memory params = SwapParams({zeroForOne: true, amountIn: amount0In, to: to, data: data});
+        return _swap(params);
     }
 
     // move from left to right (token 0 is becoming more valuable)
@@ -723,8 +685,8 @@ contract UniswapV3Pair is IUniswapV3Pair {
     ) external override lock returns (uint256 amount0Out) {
         require(amount1In > 0, 'UniswapV3Pair::swap1For0: amountIn must be greater than 0');
 
-        return
-            _swap(SwapParams({tickStart: tickCurrent(), zeroForOne: false, amountIn: amount1In, to: to, data: data}));
+        SwapParams memory params = SwapParams({zeroForOne: false, amountIn: amount1In, to: to, data: data});
+        return _swap(params);
     }
 
     function recover(
