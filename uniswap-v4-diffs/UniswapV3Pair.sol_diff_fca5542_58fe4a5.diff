diff --git a/contracts/UniswapV3Pair.sol b/contracts/UniswapV3Pair.sol
index a3bad88a..737c0a16 100644
--- a/contracts/UniswapV3Pair.sol
+++ b/contracts/UniswapV3Pair.sol
@@ -34,6 +34,7 @@ contract UniswapV3Pair is IUniswapV3Pair {
     address public immutable override token0;
     address public immutable override token1;
 
+    uint16 public lpFee; // in 100ths of a bp
     uint112 public totalFeeVote;
 
     uint112 private reserve0;           // uses single storage slot, accessible via getReserves
@@ -73,6 +74,7 @@ contract UniswapV3Pair is IUniswapV3Pair {
     // user address, lower tick, upper tick
     mapping (address => mapping (int16 => mapping (int16 => Position))) positions;
 
+
     modifier lock() {
         require(unlocked == 1, 'UniswapV3: LOCKED');
         unlocked = 0;
@@ -80,11 +82,6 @@ contract UniswapV3Pair is IUniswapV3Pair {
         unlocked = 1;
     }
 
-    // get LP fee in 100ths of a bp
-    function getLpFee() public view returns (uint16) {
-        return aggregateFeeVote.averageFee();
-    }
-
     // returns sqrt(x*y)/shares
     function getInvariant() public view returns (FixedPoint.uq112x112 memory k) {
         uint112 rootXY = uint112(Babylonian.sqrt(uint256(reserve0) * uint256(reserve1)));
@@ -121,12 +118,32 @@ contract UniswapV3Pair is IUniswapV3Pair {
     function getGrowthInside(int16 _lowerTick, int16 _upperTick) public view returns (FixedPoint.uq112x112 memory growth) {
         // TODO: simpler or more precise way to compute this?
         FixedPoint.uq112x112 memory _k = getInvariant();
+
         int16 _currentTick = currentTick;
         FixedPoint.uq112x112 memory growthAbove = getGrowthAbove(_upperTick, _currentTick, _k);
         FixedPoint.uq112x112 memory growthBelow = getGrowthBelow(_lowerTick, _currentTick, _k);
         return growthAbove.uqmul112(growthBelow).reciprocal().uqmul112(_k);
     }
 
+    function normalizeToRange(int112 liquidity, int16 lowerTick, int16 upperTick) internal view returns (int112) {
+        FixedPoint.uq112x112 memory kGrowthRange = getGrowthInside(lowerTick, upperTick);
+        if (liquidity > 0) {
+            return int112(kGrowthRange.mul112(uint112(liquidity)).decode());
+        } else {
+            return -1 * int112(kGrowthRange.mul112(uint112(liquidity * -1)).decode());
+        }
+    }
+
+    // TODO: name and explain this better
+    function denormalizeToRange(int112 liquidity, int16 lowerTick, int16 upperTick) internal view returns (int112) {
+        FixedPoint.uq112x112 memory kGrowthRange = getGrowthInside(lowerTick, upperTick);
+        if (liquidity > 0) {
+            return int112(kGrowthRange.reciprocal().mul112(uint112(liquidity)).decode());
+        } else {
+            return -1 * int112(kGrowthRange.reciprocal().mul112(uint112(liquidity * -1)).decode());
+        }
+    }
+
     function getReserves() public override view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {
         _reserve0 = reserve0;
         _reserve1 = reserve1;
@@ -153,6 +170,7 @@ contract UniswapV3Pair is IUniswapV3Pair {
         blockTimestampLast = blockTimestamp;
     }
 
+    // TODO: 
     // if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k)
     function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {
         address feeTo = IUniswapV3Factory(factory).feeTo();
@@ -185,7 +203,6 @@ contract UniswapV3Pair is IUniswapV3Pair {
 
     function getBalancesAtTick(int112 liquidity, int16 tick) internal pure returns (int112 balance0, int112 balance1) {
         if (tick == MIN_TICK || tick == MAX_TICK) {
-            // TODO: reason about this
             return (0, 0);
         }
         FixedPoint.uq112x112 memory price = getTickPrice(tick);
@@ -199,7 +216,7 @@ contract UniswapV3Pair is IUniswapV3Pair {
         FixedPoint.uq112x112 memory price = FixedPoint.encode(amount1).div(amount0);
         require(price._x > getTickPrice(startingTick)._x && price._x < getTickPrice(startingTick + 1)._x);
         bool feeOn = _mintFee(0, 0);
-        liquidity = uint112(Babylonian.sqrt(uint256(amount0).mul(uint256(amount1))).sub(MINIMUM_LIQUIDITY));
+        liquidity = uint112(Babylonian.sqrt(uint256(amount0).mul(uint256(amount1))).sub(uint(MINIMUM_LIQUIDITY)));
         require(liquidity > 0, 'UniswapV3: INSUFFICIENT_LIQUIDITY_MINTED');
         positions[address(0)][MIN_TICK][MAX_TICK] = Position({
             liquidity: MINIMUM_LIQUIDITY,
@@ -211,12 +228,12 @@ contract UniswapV3Pair is IUniswapV3Pair {
             lastAdjustedLiquidity: liquidity,
             feeVote: feeVote
         });
-        uint112 totalLiquidity = liquidity + MINIMUM_LIQUIDITY;
-        virtualSupply = totalLiquidity;
-        aggregateFeeVote = Aggregate({
-            numerator: int112(feeVote).mul(int112(totalLiquidity)),
-            denominator: int112(totalLiquidity)
-        });
+        virtualSupply = liquidity + MINIMUM_LIQUIDITY;
+        
+        // update fee
+        totalFeeVote = feeVote * liquidity;
+        lpFee = feeVote;
+
         uint112 _reserve0 = amount0;
         uint112 _reserve1 = amount1;
         _update(0, 0, _reserve0, _reserve1);
@@ -224,8 +241,15 @@ contract UniswapV3Pair is IUniswapV3Pair {
         TransferHelper.safeTransferFrom(token0, msg.sender, address(this), amount0);
         TransferHelper.safeTransferFrom(token1, msg.sender, address(this), amount1);
         if (feeOn) kLast = uint(_reserve0).mul(_reserve1);
-        emit SetPosition(address(0), int112(MINIMUM_LIQUIDITY), MIN_TICK, MAX_TICK, feeVote);
-        emit SetPosition(msg.sender, int112(liquidity), MIN_TICK, MAX_TICK, feeVote);
+        emit Edit(address(0), int112(MINIMUM_LIQUIDITY), MIN_TICK, MAX_TICK);
+        emit Edit(msg.sender, int112(liquidity), MIN_TICK, MAX_TICK);
+    }
+
+    function updateFee(Aggregate memory delta) internal {
+        Aggregate memory _aggregateFeeVote = aggregateFeeVote;
+        _aggregateFeeVote = _aggregateFeeVote.add(delta);
+        lpFee = _aggregateFeeVote.averageFee();
+        aggregateFeeVote = _aggregateFeeVote;
     }
 
     // add or remove a specified amount of liquidity from a specified range, and/or change feeVote for that range
@@ -237,42 +261,56 @@ contract UniswapV3Pair is IUniswapV3Pair {
         bool feeOn = _mintFee(_reserve0, _reserve1);
         uint112 _virtualSupply = virtualSupply; // gas savings, must be defined here since virtualSupply can update in _mintFee
         require(_virtualSupply > 0, 'UniswapV3: NOT_INITIALIZED');
-        // adjust liquidity values based on fees accumulated in the range
-        FixedPoint.uq112x112 memory adjustmentFactor = getGrowthInside(lowerTick, upperTick);
-        int112 adjustedExistingLiquidity = adjustmentFactor.smul112(int112(_position.liquidity));
-        int112 adjustedNewLiquidity = adjustmentFactor.smul112(liquidity);
-        uint112 totalAdjustedLiquidity = uint112(adjustedExistingLiquidity).sadd(adjustedNewLiquidity);
+
+        // normalized values to the range
+        // this can definitely be optimized
+        int112 adjustedExistingLiquidity = normalizeToRange(int112(_position.liquidity), lowerTick, upperTick);
+        int112 adjustedNewLiquidity = normalizeToRange(liquidity, lowerTick, upperTick);
+
         // calculate how much the new shares are worth at lower ticks and upper ticks
         (int112 lowerToken0Balance, int112 lowerToken1Balance) = getBalancesAtTick(adjustedNewLiquidity, lowerTick);
         (int112 upperToken0Balance, int112 upperToken1Balance) = getBalancesAtTick(adjustedNewLiquidity, upperTick);
+
+        uint112 totalAdjustedLiquidity = uint112(adjustedExistingLiquidity).sadd(adjustedNewLiquidity);
+
         // before moving on, withdraw any collected fees
         // until fees are collected, they are like unlevered pool shares that do not earn fees outside the range
         FixedPoint.uq112x112 memory currentPrice = FixedPoint.encode(reserve1).div(reserve0);
         int112 feeLiquidity = adjustedExistingLiquidity - int112(_position.lastAdjustedLiquidity);
         // negative amount means the amount is sent out
-        (int112 amount0, int112 amount1) = getBalancesAtPrice(-feeLiquidity, currentPrice);
-        deltas[lowerTick] = deltas[lowerTick].add(lowerToken0Balance);
-        deltas[upperTick] = deltas[upperTick].sub(upperToken0Balance);
-        // update vote deltas. since adjusted liquidity and vote could change, remove all votes and add new ones
+        (int112 amount0, int112 amount1) = getBalancesAtPrice(-1 * feeLiquidity, currentPrice);
+
+        // TODO: figure out overflow here and elsewhere
+        deltas[lowerTick] += lowerToken0Balance;
+        deltas[upperTick] -= upperToken0Balance;
+        
+        // update vote deltas. since vote could change, remove all votes and add new ones
+        int112 deltaNumerator = int16(feeVote) * int112(totalAdjustedLiquidity) - int16(_position.feeVote) * int112(_position.lastAdjustedLiquidity);
+        int112 deltaDenominator = int112(totalAdjustedLiquidity) - int112(_position.lastAdjustedLiquidity);
+
+
         Aggregate memory deltaFeeVote = Aggregate({
-            numerator: int112(feeVote) * int112(totalAdjustedLiquidity) - int112(_position.feeVote) * int112(_position.lastAdjustedLiquidity),
-            denominator: int112(totalAdjustedLiquidity) - int112(_position.lastAdjustedLiquidity)
+            numerator: deltaNumerator,
+            denominator: deltaDenominator
         });
+
         deltaFeeVotes[lowerTick] = deltaFeeVotes[lowerTick].add(deltaFeeVote);
-        deltaFeeVotes[upperTick] = deltaFeeVotes[upperTick].sub(deltaFeeVote);
+        deltaFeeVotes[upperTick] = deltaFeeVotes[upperTick].add(deltaFeeVote);
+
         if (currentTick < lowerTick) {
-            amount1 = amount1.add(lowerToken1Balance.sub(upperToken1Balance));
+            amount1 += lowerToken1Balance - upperToken1Balance;
         } else if (currentTick < upperTick) {
             (int112 virtualAmount0, int112 virtualAmount1) = getBalancesAtPrice(adjustedNewLiquidity, currentPrice);
             amount0 += virtualAmount0 - lowerToken0Balance;
             amount1 += virtualAmount1 - upperToken1Balance;
-            // price doesn't change, so no need to update oracle
-            virtualSupply = _virtualSupply.sadd(int112(int(virtualAmount0) * int(_virtualSupply) / int(reserve0)));
-            reserve0 = _reserve0.sadd(virtualAmount0);
-            reserve1 = _reserve1.sadd(virtualAmount1);
-            aggregateFeeVote = aggregateFeeVote.add(deltaFeeVote);
+            _reserve0.sadd(virtualAmount0);
+            _reserve1.sadd(virtualAmount1);
+            // yet ANOTHER adjusted liquidity amount. this converts it into unbounded liquidity
+            int112 deltaVirtualSupply = denormalizeToRange(adjustedNewLiquidity, MIN_TICK, MAX_TICK);
+            virtualSupply.sadd(deltaVirtualSupply);
+            updateFee(deltaFeeVote);
         } else {
-            amount0 = amount0.add(upperToken0Balance.sub(lowerToken0Balance));
+            amount0 += upperToken0Balance - lowerToken0Balance;
         }
         positions[msg.sender][lowerTick][upperTick] = Position({
             lastAdjustedLiquidity: totalAdjustedLiquidity,
@@ -287,7 +325,7 @@ contract UniswapV3Pair is IUniswapV3Pair {
             TransferHelper.safeTransfer(token1, msg.sender, uint112(amount1));
         }
         if (feeOn) kLast = uint(_reserve0).mul(_reserve1);
-        emit SetPosition(msg.sender, liquidity, lowerTick, upperTick, feeVote);
+        emit Edit(msg.sender, liquidity, lowerTick, upperTick);
     }
 
     function getTradeToRatio(uint112 y0, uint112 x0, FixedPoint.uq112x112 memory price, uint112 _lpFee) internal pure returns (uint112) {
@@ -309,7 +347,7 @@ contract UniswapV3Pair is IUniswapV3Pair {
 
         uint112 amountInLeft = uint112(amountIn);
         uint112 amountOut = 0;
-        uint112 _lpFee = getLpFee();
+        uint112 _lpFee = lpFee;
 
         while (amountInLeft > 0) {
             FixedPoint.uq112x112 memory price = getTickPrice(_currentTick);
@@ -344,7 +382,8 @@ contract UniswapV3Pair is IUniswapV3Pair {
                 _virtualSupply = _virtualSupply.sadd(shareDelta);
                 // kick in/out fee votes
                 Aggregate memory deltaFeeVote = deltaFeeVotes[_currentTick];
-                aggregateFeeVote = aggregateFeeVote.sub(deltaFeeVote); // sub because we're crossing the tick from right to left
+                updateFee(deltaFeeVote.negate()); // negate because we're crossing the tick from right to left
+                
                 // update tick info
                 tickInfos[_currentTick] = TickInfo({
                     // TODO: the overflow trick may not work here... we may need to switch to uint40 for timestamp
@@ -371,7 +410,7 @@ contract UniswapV3Pair is IUniswapV3Pair {
             return FixedPoint.encode(1);
         }
 
-        uint16 absIndex = index > 0 ? uint16(index) : uint16(-index);
+        uint16 absIndex = index > 0 ? uint16(index) : uint16(-1 * index);
 
         // compute 1.01^abs(index)
         // TODO: improve and fix this math, which is currently totally wrong
