diff --git a/contracts/UniswapV3Pair.sol b/contracts/UniswapV3Pair.sol
index fe0192ca..b92bdec1 100644
--- a/contracts/UniswapV3Pair.sol
+++ b/contracts/UniswapV3Pair.sol
@@ -414,7 +414,15 @@ contract UniswapV3Pair is IUniswapV3Pair {
         }
     }
 
-    struct SwapCache {
+    struct SwapParams {
+        // how much is being swapped in (positive), or requested out (negative)
+        int256 amountSpecified;
+        // the max/min price that the pair will end up at after the swap
+        uint160 sqrtPriceLimitX96;
+        // the address that receives amount out
+        address recipient;
+        // the data to send in the callback
+        bytes data;
         // the value of slot0 at the beginning of the swap
         Slot0 slot0Start;
         // the value of slot1 at the beginning of the swap
@@ -460,50 +468,25 @@ contract UniswapV3Pair is IUniswapV3Pair {
         uint256 feeAmount;
     }
 
-    // positive (negative) numbers specify exact input (output) amounts
-    function swap(
-        bool zeroForOne,
-        int256 amountSpecified,
-        uint160 sqrtPriceLimitX96,
-        address recipient,
-        bytes calldata data
-    ) external override {
-        require(amountSpecified != 0, 'AS');
-
-        Slot0 memory _slot0 = slot0;
-        SwapCache memory cache =
-            SwapCache({
-                slot0Start: _slot0,
-                slot1Start: slot1,
-                tickStart: _tickCurrent(_slot0),
-                blockTimestamp: _blockTimestamp()
-            });
-
-        require(cache.slot0Start.unlockedAndPriceBit & UNLOCKED_BIT == UNLOCKED_BIT, 'LOK');
-        require(
-            zeroForOne
-                ? sqrtPriceLimitX96 < cache.slot0Start.sqrtPriceX96
-                : sqrtPriceLimitX96 > cache.slot0Start.sqrtPriceX96,
-            'SPL'
-        );
-
-        bool exactInput = amountSpecified > 0;
+    function _swap(SwapParams memory params) private {
+        bool zeroForOne = params.sqrtPriceLimitX96 < params.slot0Start.sqrtPriceX96;
+        bool exactInput = params.amountSpecified > 0;
 
-        slot0.unlockedAndPriceBit = cache.slot0Start.unlockedAndPriceBit ^ UNLOCKED_BIT;
+        slot0.unlockedAndPriceBit = params.slot0Start.unlockedAndPriceBit ^ UNLOCKED_BIT;
 
         SwapState memory state =
             SwapState({
-                amountSpecifiedRemaining: amountSpecified,
+                amountSpecifiedRemaining: params.amountSpecified,
                 amountCalculated: 0,
-                sqrtPriceX96: cache.slot0Start.sqrtPriceX96,
-                priceBit: cache.slot0Start.unlockedAndPriceBit & PRICE_BIT == PRICE_BIT,
-                tick: cache.tickStart,
+                sqrtPriceX96: params.slot0Start.sqrtPriceX96,
+                priceBit: params.slot0Start.unlockedAndPriceBit & PRICE_BIT == PRICE_BIT,
+                tick: params.tickStart,
                 feeGrowthGlobalX128: zeroForOne ? feeGrowthGlobal0X128 : feeGrowthGlobal1X128,
-                liquidity: cache.slot1Start.liquidity
+                liquidity: params.slot1Start.liquidity
             });
 
         // continue swapping as long as we haven't used the entire input/output and haven't reached the price limit
-        while (state.amountSpecifiedRemaining != 0 && state.sqrtPriceX96 != sqrtPriceLimitX96) {
+        while (state.amountSpecifiedRemaining != 0 && state.sqrtPriceX96 != params.sqrtPriceLimitX96) {
             StepComputations memory step;
 
             step.sqrtPriceStart = state.sqrtPriceX96;
@@ -519,8 +502,12 @@ contract UniswapV3Pair is IUniswapV3Pair {
 
             (state.sqrtPriceX96, step.amountIn, step.amountOut, step.feeAmount) = SwapMath.computeSwapStep(
                 state.sqrtPriceX96,
-                (zeroForOne ? step.sqrtPriceNextX96 < sqrtPriceLimitX96 : step.sqrtPriceNextX96 > sqrtPriceLimitX96)
-                    ? sqrtPriceLimitX96
+                (
+                    zeroForOne
+                        ? step.sqrtPriceNextX96 < params.sqrtPriceLimitX96
+                        : step.sqrtPriceNextX96 > params.sqrtPriceLimitX96
+                )
+                    ? params.sqrtPriceLimitX96
                     : step.sqrtPriceNextX96,
                 state.liquidity,
                 state.amountSpecifiedRemaining,
@@ -551,7 +538,7 @@ contract UniswapV3Pair is IUniswapV3Pair {
                             step.tickNext,
                             (zeroForOne ? state.feeGrowthGlobalX128 : feeGrowthGlobal0X128),
                             (zeroForOne ? feeGrowthGlobal1X128 : state.feeGrowthGlobalX128),
-                            cache.blockTimestamp
+                            params.blockTimestamp
                         );
 
                     // update liquidity, subi from right to left, addi from left to right
@@ -570,18 +557,18 @@ contract UniswapV3Pair is IUniswapV3Pair {
         }
 
         // update liquidity if it changed
-        if (cache.slot1Start.liquidity != state.liquidity) slot1.liquidity = state.liquidity;
+        if (params.slot1Start.liquidity != state.liquidity) slot1.liquidity = state.liquidity;
 
         // the price moved at least one tick, update the accumulator
-        if (state.tick != cache.tickStart) {
-            uint32 _blockTimestampLast = cache.slot0Start.blockTimestampLast;
-            if (_blockTimestampLast != cache.blockTimestamp) {
-                slot0.blockTimestampLast = cache.blockTimestamp;
+        if (state.tick != params.tickStart) {
+            uint32 _blockTimestampLast = params.slot0Start.blockTimestampLast;
+            if (_blockTimestampLast != params.blockTimestamp) {
+                slot0.blockTimestampLast = params.blockTimestamp;
                 // overflow desired
                 slot0.tickCumulativeLast =
-                    cache.slot0Start.tickCumulativeLast +
-                    int56(cache.blockTimestamp - _blockTimestampLast) *
-                    cache.tickStart;
+                    params.slot0Start.tickCumulativeLast +
+                    int56(params.blockTimestamp - _blockTimestampLast) *
+                    params.tickStart;
             }
         }
 
@@ -595,25 +582,53 @@ contract UniswapV3Pair is IUniswapV3Pair {
         // amountIn is always >0, amountOut is always <=0
         (int256 amountIn, int256 amountOut) =
             exactInput
-                ? (amountSpecified - state.amountSpecifiedRemaining, state.amountCalculated)
-                : (state.amountCalculated, amountSpecified - state.amountSpecifiedRemaining);
+                ? (params.amountSpecified - state.amountSpecifiedRemaining, state.amountCalculated)
+                : (state.amountCalculated, params.amountSpecified - state.amountSpecifiedRemaining);
 
         (address tokenIn, address tokenOut) = zeroForOne ? (token0, token1) : (token1, token0);
 
         // transfer the output
-        TransferHelper.safeTransfer(tokenOut, recipient, uint256(-amountOut));
+        TransferHelper.safeTransfer(tokenOut, params.recipient, uint256(-amountOut));
 
         // callback for the input
         uint256 balanceBefore = balanceOfToken(tokenIn);
         zeroForOne
-            ? IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(amountIn, amountOut, data)
-            : IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(amountOut, amountIn, data);
+            ? IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(amountIn, amountOut, params.data)
+            : IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(amountOut, amountIn, params.data);
         require(balanceBefore.add(uint256(amountIn)) >= balanceOfToken(tokenIn), 'IIA');
 
         slot0.unlockedAndPriceBit = state.priceBit ? PRICE_BIT | UNLOCKED_BIT : UNLOCKED_BIT;
 
-        if (zeroForOne) emit Swap(msg.sender, recipient, amountIn, amountOut, state.sqrtPriceX96, state.tick);
-        else emit Swap(msg.sender, recipient, amountOut, amountIn, state.sqrtPriceX96, state.tick);
+        if (zeroForOne) emit Swap(msg.sender, params.recipient, amountIn, amountOut, state.sqrtPriceX96, state.tick);
+        else emit Swap(msg.sender, params.recipient, amountOut, amountIn, state.sqrtPriceX96, state.tick);
+    }
+
+    // positive (negative) numbers specify exact input (output) amounts, return values are output (input) amounts
+    function swap(
+        bool zeroForOne,
+        int256 amountSpecified,
+        uint160 sqrtPriceLimitX96,
+        address recipient,
+        bytes calldata data
+    ) external override {
+        require(amountSpecified != 0, 'AS');
+
+        Slot0 memory _slot0 = slot0;
+        require(_slot0.unlockedAndPriceBit & UNLOCKED_BIT == UNLOCKED_BIT, 'LOK');
+        require(zeroForOne ? sqrtPriceLimitX96 < _slot0.sqrtPriceX96 : sqrtPriceLimitX96 > _slot0.sqrtPriceX96, 'SPL');
+
+        _swap(
+            SwapParams({
+                amountSpecified: amountSpecified,
+                sqrtPriceLimitX96: sqrtPriceLimitX96,
+                recipient: recipient,
+                data: data,
+                slot0Start: _slot0,
+                slot1Start: slot1,
+                tickStart: _tickCurrent(_slot0),
+                blockTimestamp: _blockTimestamp()
+            })
+        );
     }
 
     function collectProtocol(
