diff --git a/src/libraries/Hooks.sol b/src/libraries/Hooks.sol
index 2358e7e5..c131b3a8 100644
--- a/src/libraries/Hooks.sol
+++ b/src/libraries/Hooks.sol
@@ -1,5 +1,5 @@
 // SPDX-License-Identifier: MIT
-pragma solidity ^0.8.24;
+pragma solidity ^0.8.0;
 
 import {PoolKey} from "../types/PoolKey.sol";
 import {IHooks} from "../interfaces/IHooks.sol";
@@ -103,7 +103,6 @@ library Hooks {
 
     /// @notice Ensures that the hook address includes at least one hook flag or dynamic fees, or is the 0 address
     /// @param self The hook to verify
-    /// @param fee The fee of the pool the hook is used with
     /// @return bool True if the hook address is valid
     function isValidHookAddress(IHooks self, uint24 fee) internal pure returns (bool) {
         // The hook can only have a flag to return a hook delta on an action if it also has the corresponding action flag
@@ -136,9 +135,8 @@ library Hooks {
                     revert(0x1c, 0x04)
                 }
                 // bubble up revert
-                let fmp := mload(0x40)
-                returndatacopy(fmp, 0, returndatasize())
-                revert(fmp, returndatasize())
+                returndatacopy(0, 0, returndatasize())
+                revert(0, returndatasize())
             }
             // allocate result byte array from the free memory pointer
             result := mload(0x40)
@@ -150,17 +148,25 @@ library Hooks {
             returndatacopy(add(result, 0x20), 0, returndatasize())
         }
 
-        // Check expected selector and returned selector match.
-        if (result.parseSelector() != data.parseSelector()) InvalidHookResponse.selector.revertWith();
+        // Length must be at least 32 to contain the selector. Check expected selector and returned selector match.
+        if (result.length < 32 || result.parseSelector() != data.parseSelector()) {
+            InvalidHookResponse.selector.revertWith();
+        }
     }
 
     /// @notice performs a hook call using the given calldata on the given hook
-    /// @return int256 The delta returned by the hook
-    function callHookWithReturnDelta(IHooks self, bytes memory data, bool parseReturn) internal returns (int256) {
+    /// @return delta The delta returned by the hook
+    function callHookWithReturnDelta(IHooks self, bytes memory data, bool parseReturn)
+        internal
+        returns (int256 delta)
+    {
         bytes memory result = callHook(self, data);
 
         // If this hook wasnt meant to return something, default to 0 delta
         if (!parseReturn) return 0;
+
+        // A length of 64 bytes is required to return a bytes4, and a 32 byte delta
+        if (result.length != 64) InvalidHookResponse.selector.revertWith();
         return result.parseReturnDelta();
     }
 
@@ -177,7 +183,9 @@ library Hooks {
         noSelfCall(self)
     {
         if (self.hasPermission(BEFORE_INITIALIZE_FLAG)) {
-            self.callHook(abi.encodeCall(IHooks.beforeInitialize, (msg.sender, key, sqrtPriceX96, hookData)));
+            self.callHook(
+                abi.encodeWithSelector(IHooks.beforeInitialize.selector, msg.sender, key, sqrtPriceX96, hookData)
+            );
         }
     }
 
@@ -187,7 +195,9 @@ library Hooks {
         noSelfCall(self)
     {
         if (self.hasPermission(AFTER_INITIALIZE_FLAG)) {
-            self.callHook(abi.encodeCall(IHooks.afterInitialize, (msg.sender, key, sqrtPriceX96, tick, hookData)));
+            self.callHook(
+                abi.encodeWithSelector(IHooks.afterInitialize.selector, msg.sender, key, sqrtPriceX96, tick, hookData)
+            );
         }
     }
 
@@ -199,9 +209,11 @@ library Hooks {
         bytes calldata hookData
     ) internal noSelfCall(self) {
         if (params.liquidityDelta > 0 && self.hasPermission(BEFORE_ADD_LIQUIDITY_FLAG)) {
-            self.callHook(abi.encodeCall(IHooks.beforeAddLiquidity, (msg.sender, key, params, hookData)));
+            self.callHook(abi.encodeWithSelector(IHooks.beforeAddLiquidity.selector, msg.sender, key, params, hookData));
         } else if (params.liquidityDelta <= 0 && self.hasPermission(BEFORE_REMOVE_LIQUIDITY_FLAG)) {
-            self.callHook(abi.encodeCall(IHooks.beforeRemoveLiquidity, (msg.sender, key, params, hookData)));
+            self.callHook(
+                abi.encodeWithSelector(IHooks.beforeRemoveLiquidity.selector, msg.sender, key, params, hookData)
+            );
         }
     }
 
@@ -250,6 +262,9 @@ library Hooks {
         if (self.hasPermission(BEFORE_SWAP_FLAG)) {
             bytes memory result = callHook(self, abi.encodeCall(IHooks.beforeSwap, (msg.sender, key, params, hookData)));
 
+            // A length of 96 bytes is required to return a bytes4, a 32 byte delta, and an LP fee
+            if (result.length != 96) InvalidHookResponse.selector.revertWith();
+
             // dynamic fee pools that do not want to override the cache fee, return 0 otherwise they return a valid fee with the override flag
             if (key.fee.isDynamicFee()) lpFeeOverride = result.parseFee();
 
@@ -311,7 +326,9 @@ library Hooks {
         noSelfCall(self)
     {
         if (self.hasPermission(BEFORE_DONATE_FLAG)) {
-            self.callHook(abi.encodeCall(IHooks.beforeDonate, (msg.sender, key, amount0, amount1, hookData)));
+            self.callHook(
+                abi.encodeWithSelector(IHooks.beforeDonate.selector, msg.sender, key, amount0, amount1, hookData)
+            );
         }
     }
 
@@ -321,7 +338,9 @@ library Hooks {
         noSelfCall(self)
     {
         if (self.hasPermission(AFTER_DONATE_FLAG)) {
-            self.callHook(abi.encodeCall(IHooks.afterDonate, (msg.sender, key, amount0, amount1, hookData)));
+            self.callHook(
+                abi.encodeWithSelector(IHooks.afterDonate.selector, msg.sender, key, amount0, amount1, hookData)
+            );
         }
     }
 
