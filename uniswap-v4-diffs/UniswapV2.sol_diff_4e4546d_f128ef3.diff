diff --git a/contracts/UniswapV2.sol b/contracts/UniswapV2.sol
index 9a8a7944..458f9159 100644
--- a/contracts/UniswapV2.sol
+++ b/contracts/UniswapV2.sol
@@ -1,11 +1,12 @@
-pragma solidity 0.5.14;
+pragma solidity 0.5.13;
 
 import "./interfaces/IUniswapV2.sol";
-import "./ERC20.sol";
-import "./libraries/UQ112x112.sol";
 import "./libraries/Math.sol";
+import "./libraries/UQ112x112.sol";
+import "./token/ERC20.sol";
+import "./token/SafeTransfer.sol";
 
-contract UniswapV2 is IUniswapV2, ERC20("Uniswap V2", "UNI-V2", 18, 0) {
+contract UniswapV2 is IUniswapV2, ERC20("Uniswap V2", "UNI-V2", 18, 0), SafeTransfer {
     using SafeMath  for uint;
     using UQ112x112 for uint224;
 
@@ -16,17 +17,12 @@ contract UniswapV2 is IUniswapV2, ERC20("Uniswap V2", "UNI-V2", 18, 0) {
     uint112 public reserve0;
     uint112 public reserve1;
     uint32  public blockNumberLast;
-    uint    public price0CumulativeLast;
-    uint    public price1CumulativeLast;
+    uint    public priceCumulative0Last;
+    uint    public priceCumulative1Last;
 
     uint private invariantLast;
-    bool private notEntered = true;
-
-    event ReservesUpdated(uint112 reserve0, uint112 reserve1);
-    event LiquidityMinted(address indexed sender, uint amount0, uint amount1);
-    event LiquidityBurned(address indexed sender, address indexed recipient, uint amount0, uint amount1);
-    event Swap(address indexed sender, address indexed recipient, address indexed input, uint amount0, uint amount1);
 
+    bool private notEntered = true;
     modifier lock() {
         require(notEntered, "UniswapV2: LOCKED");
         notEntered = false;
@@ -34,47 +30,65 @@ contract UniswapV2 is IUniswapV2, ERC20("Uniswap V2", "UNI-V2", 18, 0) {
         notEntered = true;
     }
 
+    event LiquidityMinted(
+        address indexed sender,
+        address indexed recipient,
+        uint amount0,
+        uint amount1,
+        uint128 reserve0,
+        uint128 reserve1,
+        uint liquidity
+    );
+    event LiquidityBurned(
+        address indexed sender,
+        address indexed recipient,
+        uint amount0,
+        uint amount1,
+        uint128 reserve0,
+        uint128 reserve1,
+        uint liquidity
+    );
+    event Swap(
+        address indexed sender,
+        address indexed recipient,
+        uint amount0,
+        uint amount1,
+        uint128 reserve0,
+        uint128 reserve1,
+        address input
+    );
+    event FeeLiquidityMinted(uint liquidity);
+
     constructor() public {
         factory = msg.sender;
         blockNumberLast = uint32(block.number % 2**32);
     }
 
     function initialize(address _token0, address _token1) external {
-        require(msg.sender == factory && token0 == address(0) && token1 == address(0), "UniswapV2: FORBIDDEN");
+        require(msg.sender == factory && token0 == address(0) && token1 == address(0), 'UniswapV2: FORBIDDEN');
         token0 = _token0;
         token1 = _token1;
     }
 
-    function safeTransfer(address token, address to, uint value) private {
-        // solium-disable-next-line security/no-low-level-calls
-        (bool success, bytes memory data) = token.call(abi.encodeWithSignature("transfer(address,uint256)", to, value));
-        require(success, "UniswapV2: TRANSFER_UNSUCCESSFUL");
-        if (data.length > 0) {
-            require(abi.decode(data, (bool)), "SafeTransfer: TRANSFER_FAILED");
-        }
-    }
-
     function getInputPrice(uint inputAmount, uint inputReserve, uint outputReserve) public pure returns (uint) {
-        require(inputReserve > 0 && outputReserve > 0, "UniswapV2: INSUFFICIENT_RESERVES");
+        require(inputReserve > 0 && outputReserve > 0, "UniswapV2: INVALID_VALUE");
         uint amountInputWithFee = inputAmount.mul(997);
         uint numerator = amountInputWithFee.mul(outputReserve);
         uint denominator = inputReserve.mul(1000).add(amountInputWithFee);
         return numerator / denominator;
     }
 
-    // increment price accumulators if necessary, and update reserves
     function update(uint balance0, uint balance1) private {
         uint32 blockNumber = uint32(block.number % 2**32);
         uint32 blocksElapsed = blockNumber - blockNumberLast; // overflow is desired
         if (blocksElapsed > 0 && reserve0 != 0 && reserve1 != 0) {
-            // * never overflows, and + overflow is desired
-            price0CumulativeLast += uint256(UQ112x112.encode(reserve0).qdiv(reserve1)) * blocksElapsed;
-            price1CumulativeLast += uint256(UQ112x112.encode(reserve1).qdiv(reserve0)) * blocksElapsed;
+            // in the following 2 lines, * never overflows, + overflow is desired
+            priceCumulative0Last += uint256(UQ112x112.encode(reserve0).qdiv(reserve1)) * blocksElapsed;
+            priceCumulative1Last += uint256(UQ112x112.encode(reserve1).qdiv(reserve0)) * blocksElapsed;
         }
-        reserve0 = Math.clamp112(balance0);
-        reserve1 = Math.clamp112(balance1);
+        reserve0 = balance0.clamp112();
+        reserve1 = balance1.clamp112();
         blockNumberLast = blockNumber;
-        emit ReservesUpdated(reserve0, reserve1);
     }
 
     // mint liquidity equivalent to 20% of accumulated fees
@@ -84,16 +98,15 @@ contract UniswapV2 is IUniswapV2, ERC20("Uniswap V2", "UNI-V2", 18, 0) {
             uint numerator = totalSupply.mul(invariant.sub(invariantLast));
             uint denominator = uint256(4).mul(invariant).add(invariantLast);
             uint liquidity = numerator / denominator;
-            if (liquidity > 0) {
-                _mint(factory, liquidity); // factory is a placeholder
-            }
+            _mint(factory, liquidity); // factory is just a placeholder
+            emit FeeLiquidityMinted(liquidity);
         }
     }
 
     function mintLiquidity(address recipient) external lock returns (uint liquidity) {
         uint balance0 = IERC20(token0).balanceOf(address(this));
         uint balance1 = IERC20(token1).balanceOf(address(this));
-        require(balance0 <= uint112(-1) && balance1 <= uint112(-1), "UniswapV2: EXCESS_BALANCES");
+        require(balance0 <= uint112(-1) && balance1 <= uint112(-1), "UniswapV2: EXCESS_LIQUIDITY");
         uint amount0 = balance0.sub(reserve0);
         uint amount1 = balance1.sub(reserve1);
 
@@ -101,31 +114,31 @@ contract UniswapV2 is IUniswapV2, ERC20("Uniswap V2", "UNI-V2", 18, 0) {
         liquidity = totalSupply == 0 ?
             Math.sqrt(amount0.mul(amount1)) :
             Math.min(amount0.mul(totalSupply) / reserve0, amount1.mul(totalSupply) / reserve1);
-        require(liquidity > 0, "UniswapV2: INSUFFICIENT_LIQUIDITY");
+        require(liquidity > 0, "UniswapV2: INSUFFICIENT_VALUE");
         _mint(recipient, liquidity);
 
         update(balance0, balance1);
         invariantLast = Math.sqrt(uint(reserve0).mul(reserve1));
-        emit LiquidityMinted(msg.sender, amount0, amount1);
+        emit LiquidityMinted(msg.sender, recipient, amount0, amount1, reserve0, reserve1, liquidity);
     }
 
     function burnLiquidity(address recipient) external lock returns (uint amount0, uint amount1) {
         uint liquidity = balanceOf[address(this)];
         uint balance0 = IERC20(token0).balanceOf(address(this));
         uint balance1 = IERC20(token1).balanceOf(address(this));
-        require(balance0 >= reserve0 && balance0 >= reserve1, "UniswapV2: INSUFFICIENT_BALANCES");
+        require(balance0 >= reserve0 && balance0 >= reserve1, "UniswapV2: INSUFFICIENT_BALANCE");
 
         mintFeeLiquidity();
         amount0 = liquidity.mul(balance0) / totalSupply; // intentionally using balances not reserves
         amount1 = liquidity.mul(balance1) / totalSupply; // intentionally using balances not reserves
-        require(amount0 > 0 && amount1 > 0, "UniswapV2: INSUFFICIENT_AMOUNTS");
+        require(amount0 > 0 && amount1 > 0, "UniswapV2: INSUFFICIENT_VALUE");
         safeTransfer(token0, recipient, amount0);
         safeTransfer(token1, recipient, amount1);
         _burn(address(this), liquidity);
 
         update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)));
         invariantLast = Math.sqrt(uint(reserve0).mul(reserve1));
-        emit LiquidityBurned(msg.sender, recipient, amount0, amount1);
+        emit LiquidityBurned(msg.sender, recipient, amount0, amount1, reserve0, reserve1, liquidity);
     }
 
     function swap0(address recipient) external lock returns (uint amount1) {
@@ -134,11 +147,11 @@ contract UniswapV2 is IUniswapV2, ERC20("Uniswap V2", "UNI-V2", 18, 0) {
         uint amount0 = balance0.sub(reserve0);
 
         amount1 = getInputPrice(amount0, reserve0, reserve1);
-        require(amount1 > 0, "UniswapV2: INSUFFICIENT_AMOUNT");
+        require(amount1 > 0, "UniswapV2: INSUFFICIENT_VALUE");
         safeTransfer(token1, recipient, amount1);
 
         update(balance0, IERC20(token1).balanceOf(address(this)));
-        emit Swap(msg.sender, recipient, token0, amount0, amount1);
+        emit Swap(msg.sender, recipient, amount0, amount1, reserve0, reserve1, token0);
     }
 
     function swap1(address recipient) external lock returns (uint amount0) {
@@ -147,14 +160,14 @@ contract UniswapV2 is IUniswapV2, ERC20("Uniswap V2", "UNI-V2", 18, 0) {
         uint amount1 = balance1.sub(reserve1);
 
         amount0 = getInputPrice(amount1, reserve1, reserve0);
-        require(amount0 > 0, "UniswapV2: INSUFFICIENT_AMOUNT");
+        require(amount0 > 0, "UniswapV2: INSUFFICIENT_VALUE");
         safeTransfer(token0, recipient, amount0);
 
         update(IERC20(token0).balanceOf(address(this)), balance1);
-        emit Swap(msg.sender, recipient, token1, amount0, amount1);
+        emit Swap(msg.sender, recipient, amount0, amount1, reserve0, reserve1, token1);
     }
 
-    // almost certainly never needs to be called, but can be helpful for oracles and possibly some weird tokens
+    // almost never _needs_ to be called, it's for weird tokens and can also be helpful for oracles
     function sync() external lock {
         update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)));
     }
