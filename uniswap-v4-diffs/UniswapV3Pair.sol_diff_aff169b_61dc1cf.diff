diff --git a/contracts/UniswapV3Pair.sol b/contracts/UniswapV3Pair.sol
index 876786c1..b73aa8ed 100644
--- a/contracts/UniswapV3Pair.sol
+++ b/contracts/UniswapV3Pair.sol
@@ -104,7 +104,7 @@ contract UniswapV3Pair is IUniswapV3Pair {
     }
 
     // gets the growth in K for within a particular range
-    // this only has relative meaning, not absolute
+    // this only has relative meaning, not absoluteâ€”under some circumstances, it can even be less than 1
     function getGrowthInside(int16 _lowerTick, int16 _upperTick) public view returns (FixedPoint.uq112x112 memory growth) {
         // TODO: simpler or more precise way to compute this?
         FixedPoint.uq112x112 memory _k = getInvariant();
@@ -228,23 +228,12 @@ contract UniswapV3Pair is IUniswapV3Pair {
         aggregateFeeVote = aggregateFeeVote.add(deltaFeeVote);
     }
 
-    function _getOrInitializeTick(int16 tickIndex, int16 _currentTick) internal returns (TickInfo memory tickInfo) {
-        tickInfo = tickInfos[tickIndex];
-        if (tickInfo.kGrowthOutside._x == 0) {
-            // by convention, we assume that all growth before tick was initialized happened _below_ a tick
-            if (tickIndex <= _currentTick) {
-                tickInfo = TickInfo({
-                    secondsGrowthOutside: uint32(now % 2**32),
-                    kGrowthOutside: getInvariant();
-                });
-                tickInfos[tickIndex] = tickInfo;
-            } else {
-                tickInfos[tickIndex] = TickInfo({
-                    secondsGrowthOutside: 0,
-                    kGrowthOutside: FixedPoint.encode(1)
-                });
-                tickInfos[tickIndex] = tickInfo;
-            }
+    function _initializeTick(int16 tickIndex) internal {
+        if (tickInfos[tickIndex].kGrowthOutside._x == 0) {
+            tickInfos[tickIndex] = TickInfo({
+                secondsGrowthOutside: 0,
+                kGrowthOutside: FixedPoint.encode(1)
+            });
         }
     }
 
@@ -253,12 +242,11 @@ contract UniswapV3Pair is IUniswapV3Pair {
         require(feeVote > MIN_FEEVOTE && feeVote < MAX_FEEVOTE, "UniswapV3: INVALID_FEE_VOTE");
         require(lowerTick < upperTick, "UniswapV3: BAD_TICKS");
         bytes32 positionKey = keccak256(abi.encodePacked(msg.sender, lowerTick, upperTick));
-        require(virtualSupply > 0, 'UniswapV3: NOT_INITIALIZED');
         Position memory _position = positions[positionKey];
-        int16 _currentTick = currentTick;
+        require(virtualSupply > 0, 'UniswapV3: NOT_INITIALIZED');
         // initialize tickInfos if they don't exist yet
-        _getOrInitializeTick(lowerTick, _currentTick);
-        _getOrInitializeTick(upperTick, _currentTick);
+        _initializeTick(lowerTick);
+        _initializeTick(upperTick);
         // adjust liquidity values based on fees accumulated in the range
         FixedPoint.uq112x112 memory adjustmentFactor = getGrowthInside(lowerTick, upperTick);
         int112 adjustedExistingLiquidity = adjustmentFactor.smul112(int112(_position.liquidity));
