diff --git a/src/libraries/CurrencyDelta.sol b/src/libraries/CurrencyDelta.sol
index 32002e4d..5f4be94c 100644
--- a/src/libraries/CurrencyDelta.sol
+++ b/src/libraries/CurrencyDelta.sol
@@ -1,35 +1,42 @@
 // SPDX-License-Identifier: BUSL-1.1
-pragma solidity ^0.8.24;
+pragma solidity ^0.8.20;
 
 import {Currency} from "../types/Currency.sol";
 
 /// @title a library to store callers' currency deltas in transient storage
 /// @dev this library implements the equivalent of a mapping, as transient storage can only be accessed in assembly
 library CurrencyDelta {
-    /// @notice calculates which storage slot a delta should be stored in for a given caller and currency
-    function _computeSlot(address caller_, Currency currency) internal pure returns (bytes32 hashSlot) {
+    /// @notice calculates which storage slot a delta should be stored in for a given account and currency
+    function _computeSlot(address target, Currency currency) internal pure returns (bytes32 hashSlot) {
         assembly ("memory-safe") {
-            mstore(0, caller_)
+            mstore(0, target)
             mstore(32, currency)
             hashSlot := keccak256(0, 64)
         }
     }
 
-    /// @notice sets a new currency delta for a given caller and currency
-    function setDelta(Currency currency, address caller, int256 delta) internal {
-        bytes32 hashSlot = _computeSlot(caller, currency);
-
+    function getDelta(Currency currency, address target) internal view returns (int256 delta) {
+        bytes32 hashSlot = _computeSlot(target, currency);
         assembly {
-            tstore(hashSlot, delta)
+            delta := tload(hashSlot)
         }
     }
 
-    /// @notice gets a new currency delta for a given caller and currency
-    function getDelta(Currency currency, address caller) internal view returns (int256 delta) {
-        bytes32 hashSlot = _computeSlot(caller, currency);
+    /// @notice applies a new currency delta for a given account and currency
+    /// @return previous The prior value
+    /// @return next The modified result
+    function applyDelta(Currency currency, address target, int128 delta)
+        internal
+        returns (int256 previous, int256 next)
+    {
+        bytes32 hashSlot = _computeSlot(target, currency);
 
         assembly {
-            delta := tload(hashSlot)
+            previous := tload(hashSlot)
+        }
+        next = previous + delta;
+        assembly {
+            tstore(hashSlot, next)
         }
     }
 }
