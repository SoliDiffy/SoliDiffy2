diff --git a/src/libraries/Pool.sol b/src/libraries/Pool.sol
index 0dfa9b36..6db70683 100644
--- a/src/libraries/Pool.sol
+++ b/src/libraries/Pool.sol
@@ -237,12 +237,18 @@ library Pool {
         }
     }
 
-    // the results after a swap, written to storage and returned
-    struct SwapResult {
-        // the final current sqrt(price)
+    // the top level state of the swap, the results of which are recorded in storage at the end
+    struct SwapState {
+        // the amount remaining to be swapped in/out of the input/output asset
+        int256 amountSpecifiedRemaining;
+        // the amount already swapped out/in of the output/input asset
+        int256 amountCalculated;
+        // current sqrt(price)
         uint160 sqrtPriceX96;
         // the tick associated with the current price
         int24 tick;
+        // the global fee growth of the input token
+        uint256 feeGrowthGlobalX128;
         // the current liquidity in range
         uint128 liquidity;
     }
@@ -276,7 +282,7 @@ library Pool {
     /// @dev PoolManager checks that the pool is initialized before calling
     function swap(State storage self, SwapParams memory params)
         internal
-        returns (BalanceDelta swapDelta, uint256 amountToProtocol, uint24 swapFee, SwapResult memory result)
+        returns (BalanceDelta result, uint256 amountToProtocol, uint24 swapFee, SwapState memory state)
     {
         Slot0 slot0Start = self.slot0;
         bool zeroForOne = params.zeroForOne;
@@ -285,18 +291,12 @@ library Pool {
         uint256 protocolFee =
             zeroForOne ? slot0Start.protocolFee().getZeroForOneFee() : slot0Start.protocolFee().getOneForZeroFee();
 
-        // the amount remaining to be swapped in/out of the input/output asset. initially set to the amountSpecified
-        int256 amountSpecifiedRemaining = params.amountSpecified;
-        // the amount swapped out/in of the output/input asset. initially set to 0
-        int256 amountCalculated = 0;
-        // the global fee growth of the input token. updated in storage at the end of swap
-        uint256 feeGrowthGlobalX128 = zeroForOne ? self.feeGrowthGlobal0X128 : self.feeGrowthGlobal1X128;
-        // initialize to the current sqrt(price)
-        result.sqrtPriceX96 = slot0Start.sqrtPriceX96();
-        // initialize to the current tick
-        result.tick = slot0Start.tick();
-        // initialize to the current liquidity
-        result.liquidity = liquidityStart;
+        state.amountSpecifiedRemaining = params.amountSpecified;
+        state.amountCalculated = 0;
+        state.sqrtPriceX96 = slot0Start.sqrtPriceX96();
+        state.tick = slot0Start.tick();
+        state.feeGrowthGlobalX128 = zeroForOne ? self.feeGrowthGlobal0X128 : self.feeGrowthGlobal1X128;
+        state.liquidity = liquidityStart;
 
         // if the beforeSwap hook returned a valid fee override, use that as the LP fee, otherwise load from storage
         // lpFee, swapFee, and protocolFee are all in pips
@@ -318,7 +318,7 @@ library Pool {
 
         // 0 is the fee amount that should be paid to the protocol
         // swapFee is the pool's fee in pips (LP fee + protocol fee)
-        if (params.amountSpecified == 0) return (BalanceDeltaLibrary.ZERO_DELTA, 0, swapFee, result);
+        if (params.amountSpecified == 0) return (BalanceDeltaLibrary.ZERO_DELTA, 0, swapFee, state);
 
         if (zeroForOne) {
             if (params.sqrtPriceLimitX96 >= slot0Start.sqrtPriceX96()) {
@@ -339,11 +339,11 @@ library Pool {
         StepComputations memory step;
 
         // continue swapping as long as we haven't used the entire input/output and haven't reached the price limit
-        while (!(amountSpecifiedRemaining == 0 || result.sqrtPriceX96 == params.sqrtPriceLimitX96)) {
-            step.sqrtPriceStartX96 = result.sqrtPriceX96;
+        while (!(state.amountSpecifiedRemaining == 0 || state.sqrtPriceX96 == params.sqrtPriceLimitX96)) {
+            step.sqrtPriceStartX96 = state.sqrtPriceX96;
 
             (step.tickNext, step.initialized) =
-                self.tickBitmap.nextInitializedTickWithinOneWord(result.tick, params.tickSpacing, zeroForOne);
+                self.tickBitmap.nextInitializedTickWithinOneWord(state.tick, params.tickSpacing, zeroForOne);
 
             // ensure that we do not overshoot the min/max tick, as the tick bitmap is not aware of these bounds
             if (step.tickNext <= TickMath.MIN_TICK) {
@@ -357,25 +357,25 @@ library Pool {
             step.sqrtPriceNextX96 = TickMath.getSqrtPriceAtTick(step.tickNext);
 
             // compute values to swap to the target tick, price limit, or point where input/output amount is exhausted
-            (result.sqrtPriceX96, step.amountIn, step.amountOut, step.feeAmount) = SwapMath.computeSwapStep(
-                result.sqrtPriceX96,
+            (state.sqrtPriceX96, step.amountIn, step.amountOut, step.feeAmount) = SwapMath.computeSwapStep(
+                state.sqrtPriceX96,
                 SwapMath.getSqrtPriceTarget(zeroForOne, step.sqrtPriceNextX96, params.sqrtPriceLimitX96),
-                result.liquidity,
-                amountSpecifiedRemaining,
+                state.liquidity,
+                state.amountSpecifiedRemaining,
                 swapFee
             );
 
             if (!exactInput) {
                 unchecked {
-                    amountSpecifiedRemaining -= step.amountOut.toInt256();
+                    state.amountSpecifiedRemaining -= step.amountOut.toInt256();
                 }
-                amountCalculated -= (step.amountIn + step.feeAmount).toInt256();
+                state.amountCalculated -= (step.amountIn + step.feeAmount).toInt256();
             } else {
                 // safe because we test that amountSpecified > amountIn + feeAmount in SwapMath
                 unchecked {
-                    amountSpecifiedRemaining += (step.amountIn + step.feeAmount).toInt256();
+                    state.amountSpecifiedRemaining += (step.amountIn + step.feeAmount).toInt256();
                 }
-                amountCalculated += step.amountOut.toInt256();
+                state.amountCalculated += step.amountOut.toInt256();
             }
 
             // if the protocol fee is on, calculate how much is owed, decrement feeAmount, and increment protocolFee
@@ -392,19 +392,19 @@ library Pool {
             }
 
             // update global fee tracker
-            if (result.liquidity > 0) {
+            if (state.liquidity > 0) {
                 unchecked {
-                    feeGrowthGlobalX128 += FullMath.mulDiv(step.feeAmount, FixedPoint128.Q128, result.liquidity);
+                    state.feeGrowthGlobalX128 += FullMath.mulDiv(step.feeAmount, FixedPoint128.Q128, state.liquidity);
                 }
             }
 
             // shift tick if we reached the next price
-            if (result.sqrtPriceX96 == step.sqrtPriceNextX96) {
+            if (state.sqrtPriceX96 == step.sqrtPriceNextX96) {
                 // if the tick is initialized, run the tick transition
                 if (step.initialized) {
                     (uint256 feeGrowthGlobal0X128, uint256 feeGrowthGlobal1X128) = zeroForOne
-                        ? (feeGrowthGlobalX128, self.feeGrowthGlobal1X128)
-                        : (self.feeGrowthGlobal0X128, feeGrowthGlobalX128);
+                        ? (state.feeGrowthGlobalX128, self.feeGrowthGlobal1X128)
+                        : (self.feeGrowthGlobal0X128, state.feeGrowthGlobalX128);
                     int128 liquidityNet =
                         Pool.crossTick(self, step.tickNext, feeGrowthGlobal0X128, feeGrowthGlobal1X128);
                     // if we're moving leftward, we interpret liquidityNet as the opposite sign
@@ -413,38 +413,40 @@ library Pool {
                         if (zeroForOne) liquidityNet = -liquidityNet;
                     }
 
-                    result.liquidity = LiquidityMath.addDelta(result.liquidity, liquidityNet);
+                    state.liquidity = LiquidityMath.addDelta(state.liquidity, liquidityNet);
                 }
 
                 unchecked {
-                    result.tick = zeroForOne ? step.tickNext - 1 : step.tickNext;
+                    state.tick = zeroForOne ? step.tickNext - 1 : step.tickNext;
                 }
-            } else if (result.sqrtPriceX96 != step.sqrtPriceStartX96) {
+            } else if (state.sqrtPriceX96 != step.sqrtPriceStartX96) {
                 // recompute unless we're on a lower tick boundary (i.e. already transitioned ticks), and haven't moved
-                result.tick = TickMath.getTickAtSqrtPrice(result.sqrtPriceX96);
+                state.tick = TickMath.getTickAtSqrtPrice(state.sqrtPriceX96);
             }
         }
 
-        self.slot0 = slot0Start.setTick(result.tick).setSqrtPriceX96(result.sqrtPriceX96);
+        self.slot0 = slot0Start.setTick(state.tick).setSqrtPriceX96(state.sqrtPriceX96);
 
         // update liquidity if it changed
-        if (liquidityStart != result.liquidity) self.liquidity = result.liquidity;
+        if (liquidityStart != state.liquidity) self.liquidity = state.liquidity;
 
         // update fee growth global
         if (!zeroForOne) {
-            self.feeGrowthGlobal1X128 = feeGrowthGlobalX128;
+            self.feeGrowthGlobal1X128 = state.feeGrowthGlobalX128;
         } else {
-            self.feeGrowthGlobal0X128 = feeGrowthGlobalX128;
+            self.feeGrowthGlobal0X128 = state.feeGrowthGlobalX128;
         }
 
         unchecked {
             if (zeroForOne != exactInput) {
-                swapDelta = toBalanceDelta(
-                    amountCalculated.toInt128(), (params.amountSpecified - amountSpecifiedRemaining).toInt128()
+                result = toBalanceDelta(
+                    state.amountCalculated.toInt128(),
+                    (params.amountSpecified - state.amountSpecifiedRemaining).toInt128()
                 );
             } else {
-                swapDelta = toBalanceDelta(
-                    (params.amountSpecified - amountSpecifiedRemaining).toInt128(), amountCalculated.toInt128()
+                result = toBalanceDelta(
+                    (params.amountSpecified - state.amountSpecifiedRemaining).toInt128(),
+                    state.amountCalculated.toInt128()
                 );
             }
         }
