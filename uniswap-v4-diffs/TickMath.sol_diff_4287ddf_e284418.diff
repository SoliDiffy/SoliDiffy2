diff --git a/src/libraries/TickMath.sol b/src/libraries/TickMath.sol
index abc7adcd..3a80ebf7 100644
--- a/src/libraries/TickMath.sol
+++ b/src/libraries/TickMath.sol
@@ -1,5 +1,5 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
-pragma solidity ^0.8.20;
+pragma solidity ^0.8.0;
 
 /// @title Math library for computing sqrt prices from ticks and vice versa
 /// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports
@@ -50,7 +50,7 @@ library TickMath {
     function getSqrtPriceAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {
         unchecked {
             uint256 absTick;
-            assembly ("memory-safe") {
+            assembly {
                 // mask = 0 if tick >= 0 else -1 (all 1s)
                 let mask := sar(255, tick)
                 // if tick >= 0, |tick| = tick = 0 ^ tick
@@ -71,7 +71,7 @@ library TickMath {
             //     price = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;
             //     or price = int(2**128 / sqrt(1.0001)) if (absTick & 0x1) else 1 << 128
             uint256 price;
-            assembly ("memory-safe") {
+            assembly {
                 price := xor(shl(128, 1), mul(xor(shl(128, 1), 0xfffcb933bd6fad37aa2d162d1a594001), and(absTick, 0x1)))
             }
             if (absTick & 0x2 != 0) price = (price * 0xfff97272373d413259a46990580e213a) >> 128;
@@ -94,7 +94,7 @@ library TickMath {
             if (absTick & 0x40000 != 0) price = (price * 0x2216e584f5fa1ea926041bedfe98) >> 128;
             if (absTick & 0x80000 != 0) price = (price * 0x48a170391f7dc42444e8fa2) >> 128;
 
-            assembly ("memory-safe") {
+            assembly {
                 // if (tick > 0) price = type(uint256).max / price;
                 if sgt(tick, 0) { price := div(not(0), price) }
 
@@ -132,42 +132,42 @@ library TickMath {
             uint256 r = price;
             uint256 msb = 0;
 
-            assembly ("memory-safe") {
+            assembly {
                 let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))
                 msb := or(msb, f)
                 r := shr(f, r)
             }
-            assembly ("memory-safe") {
+            assembly {
                 let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))
                 msb := or(msb, f)
                 r := shr(f, r)
             }
-            assembly ("memory-safe") {
+            assembly {
                 let f := shl(5, gt(r, 0xFFFFFFFF))
                 msb := or(msb, f)
                 r := shr(f, r)
             }
-            assembly ("memory-safe") {
+            assembly {
                 let f := shl(4, gt(r, 0xFFFF))
                 msb := or(msb, f)
                 r := shr(f, r)
             }
-            assembly ("memory-safe") {
+            assembly {
                 let f := shl(3, gt(r, 0xFF))
                 msb := or(msb, f)
                 r := shr(f, r)
             }
-            assembly ("memory-safe") {
+            assembly {
                 let f := shl(2, gt(r, 0xF))
                 msb := or(msb, f)
                 r := shr(f, r)
             }
-            assembly ("memory-safe") {
+            assembly {
                 let f := shl(1, gt(r, 0x3))
                 msb := or(msb, f)
                 r := shr(f, r)
             }
-            assembly ("memory-safe") {
+            assembly {
                 let f := gt(r, 0x1)
                 msb := or(msb, f)
             }
@@ -177,85 +177,85 @@ library TickMath {
 
             int256 log_2 = (int256(msb) - 128) << 64;
 
-            assembly ("memory-safe") {
+            assembly {
                 r := shr(127, mul(r, r))
                 let f := shr(128, r)
                 log_2 := or(log_2, shl(63, f))
                 r := shr(f, r)
             }
-            assembly ("memory-safe") {
+            assembly {
                 r := shr(127, mul(r, r))
                 let f := shr(128, r)
                 log_2 := or(log_2, shl(62, f))
                 r := shr(f, r)
             }
-            assembly ("memory-safe") {
+            assembly {
                 r := shr(127, mul(r, r))
                 let f := shr(128, r)
                 log_2 := or(log_2, shl(61, f))
                 r := shr(f, r)
             }
-            assembly ("memory-safe") {
+            assembly {
                 r := shr(127, mul(r, r))
                 let f := shr(128, r)
                 log_2 := or(log_2, shl(60, f))
                 r := shr(f, r)
             }
-            assembly ("memory-safe") {
+            assembly {
                 r := shr(127, mul(r, r))
                 let f := shr(128, r)
                 log_2 := or(log_2, shl(59, f))
                 r := shr(f, r)
             }
-            assembly ("memory-safe") {
+            assembly {
                 r := shr(127, mul(r, r))
                 let f := shr(128, r)
                 log_2 := or(log_2, shl(58, f))
                 r := shr(f, r)
             }
-            assembly ("memory-safe") {
+            assembly {
                 r := shr(127, mul(r, r))
                 let f := shr(128, r)
                 log_2 := or(log_2, shl(57, f))
                 r := shr(f, r)
             }
-            assembly ("memory-safe") {
+            assembly {
                 r := shr(127, mul(r, r))
                 let f := shr(128, r)
                 log_2 := or(log_2, shl(56, f))
                 r := shr(f, r)
             }
-            assembly ("memory-safe") {
+            assembly {
                 r := shr(127, mul(r, r))
                 let f := shr(128, r)
                 log_2 := or(log_2, shl(55, f))
                 r := shr(f, r)
             }
-            assembly ("memory-safe") {
+            assembly {
                 r := shr(127, mul(r, r))
                 let f := shr(128, r)
                 log_2 := or(log_2, shl(54, f))
                 r := shr(f, r)
             }
-            assembly ("memory-safe") {
+            assembly {
                 r := shr(127, mul(r, r))
                 let f := shr(128, r)
                 log_2 := or(log_2, shl(53, f))
                 r := shr(f, r)
             }
-            assembly ("memory-safe") {
+            assembly {
                 r := shr(127, mul(r, r))
                 let f := shr(128, r)
                 log_2 := or(log_2, shl(52, f))
                 r := shr(f, r)
             }
-            assembly ("memory-safe") {
+            assembly {
                 r := shr(127, mul(r, r))
                 let f := shr(128, r)
                 log_2 := or(log_2, shl(51, f))
                 r := shr(f, r)
             }
-            assembly ("memory-safe") {
+            assembly {
                 r := shr(127, mul(r, r))
                 let f := shr(128, r)
                 log_2 := or(log_2, shl(50, f))
